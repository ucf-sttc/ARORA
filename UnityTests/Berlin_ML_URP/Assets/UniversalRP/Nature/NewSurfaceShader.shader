Shader "Universal Render Pipeline/Mtree/Leafs"
{
	Properties
	{
		[Header(Albedo Texture)] _Color("Color", Color) = (1,1,1,1)
		_MainTex("Albedo", 2D) = "white" {}
		[Enum(Off,0,Front,1,Back,2)]_CullMode("Cull Mode", Int) = 0
		[Enum(Flip,0,Mirror,1,None,2)]_DoubleSidedNormalMode("Double Sided Normal Mode", Int) = 0
		_Cutoff("Cutoff", Range(0 , 1)) = 0.5
		[Header(Normal Texture)]_BumpMap("Normal Map", 2D) = "bump" {}
		_BumpScale("Normal Strength", Float) = 1
		[Enum(On,0,Off,1)][Header(Color Settings)]_ColorShifting("Color Shifting", Int) = 1
		_Hue("Hue", Range(-0.5 , 0.5)) = -0.5
		_Value("Value", Range(0 , 3)) = 1
		_Saturation("Saturation", Range(0 , 2)) = 1
		_ColorVariation("Color Variation", Range(0 , 0.3)) = 0.15
		[Header(Other Settings)]_OcclusionStrength("AO strength", Range(0 , 1)) = 0.6
		_Metallic("Metallic", Range(0 , 1)) = 0
		_Glossiness("Smoothness", Range(0 , 1)) = 0
		[Header(Translucency)]
		_Translucency("Strength", Range(0 , 50)) = 1
		_TransNormalDistortion("Normal Distortion", Range(0 , 1)) = 0.1
		_TransScattering("Scaterring Falloff", Range(1 , 50)) = 2
		_TransDirect("Direct", Range(0 , 1)) = 1
		_TransAmbient("Ambient", Range(0 , 1)) = 0.2
		_TransShadow("Shadow", Range(0 , 1)) = 0.9
		[HDR]_TranslucencyTint("Translucency Tint", Color) = (0.2364577,0.3301887,0,1)
		[HDR]_TransmissionTint("Transmission Tint", Color) = (0.2352941,0.3294118,0,1)
		[Header(Wind)]_GlobalWindInfluence("Global Wind Influence", Range(0 , 1)) = 1
		_GlobalTurbulenceInfluence("Global Turbulence Influence", Range(0 , 1)) = 1
		[Enum(Leaves,0,Palm,1,Grass,2,Off,3)]_WindModeLeaves("Wind Mode Leaves", Int) = 0
		[HideInInspector] _texcoord4("", 2D) = "white" {}
		[HideInInspector] _texcoord("", 2D) = "white" {}
		[HideInInspector] __dirty("", Int) = 1
		[Header(Forward Rendering Options)]
		[ToggleOff] _SpecularHighlights("Specular Highlights", Float) = 1.0
		[ToggleOff] _GlossyReflections("Reflections", Float) = 1.0

		_ObjectSegmentationColor("Object segmentation color",Color) = (1,1,1,1)
		_TagSegmentationColor("Tag segmentation color",Color) = (1,1,1,1)
		_LayerSegmentationColor("Layer segmentation color",Color) = (1,1,1,1)
	}

		SubShader
		{
			Tags{ "RenderType" = "TransparentCutout"  "Queue" = "Geometry+0" }
			Cull[_CullMode]

			// ------------------------------------------------------------
			// Surface shader code generated out of a CGPROGRAM block:


			// ---- forward rendering base pass:
			Pass {
				Name "FORWARD"
				Tags { "LightMode" = "ForwardBase" }

		CGPROGRAM
			// compile directives
			#pragma vertex vert_surf
			#pragma fragment frag_surf
			#pragma target 3.0
			#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
			#pragma shader_feature _GLOSSYREFLECTIONS_OFF
			#pragma multi_compile __ LOD_FADE_CROSSFADE
			#pragma multi_compile_instancing
			#pragma multi_compile_fog
			#pragma multi_compile_fwdbase
			#include "HLSLSupport.cginc"
			#define UNITY_INSTANCED_LOD_FADE
			#define UNITY_INSTANCED_SH
			#define UNITY_INSTANCED_LIGHTMAPSTS
			#include "UnityShaderVariables.cginc"
			#include "UnityShaderUtilities.cginc"
			// -------- variant for: <when no other keywords are defined>
			#if !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_GLOSSYREFLECTIONS_OFF) && !defined(_SPECULARHIGHLIGHTS_OFF)
			// Surface shader code generated based on:
			// vertex modifier: 'vertexDataFunc'
			// writes to per-pixel normal: YES
			// writes to emission: no
			// writes to occlusion: YES
			// needs world space reflection vector: no
			// needs world space normal vector: no
			// needs screen space position: no
			// needs world space position: no
			// needs view direction: no
			// needs world space view direction: no
			// needs world space position for lighting: YES
			// needs world space view direction for lighting: YES
			// needs world space view direction for lightmaps: no
			// needs vertex color: YES
			// needs VFACE: YES
			// passes tangent-to-world matrix to pixel shader: YES
			// reads from normal: no
			// 2 texcoords actually used
			//   float2 _texcoord
			//   float2 _texcoord4
			#include "UnityCG.cginc"
			#include "Lighting.cginc"
			#include "AutoLight.cginc"

			#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
			#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
			#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

			// Original surface shader snippet:
			#line 48 ""
			#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
			#endif
			/* UNITY: Original start of shader */
					#include "UnityShaderVariables.cginc"
					#include "UnityStandardUtils.cginc"
					#include "UnityPBSLighting.cginc"
					//#pragma target 3.0
					//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
					//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
					//#pragma multi_compile __ LOD_FADE_CROSSFADE
					//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
					struct Input
					{
						float2 uv_texcoord;
						half ASEVFace : VFACE;
						float4 vertexColor : COLOR;
						float2 uv4_texcoord4;
						float4 screenPosition;
					};

					struct SurfaceOutputStandardCustom
					{
						half3 Albedo;
						half3 Normal;
						half3 Emission;
						half Metallic;
						half Smoothness;
						half Occlusion;
						half Alpha;
						half3 Transmission;
						half3 Translucency;
					};

					uniform int _WindModeLeaves;
					uniform float _WindStrength;
					uniform float _GlobalWindInfluence;
					uniform float _RandomWindOffset;
					uniform float _WindPulse;
					uniform float _WindDirection;
					uniform float _WindTurbulence;
					uniform float _GlobalTurbulenceInfluence;
					uniform int _DoubleSidedNormalMode;
					uniform int _CullMode;
					uniform sampler2D _BumpMap;
					uniform float4 _BumpMap_ST;
					uniform half _BumpScale;
					uniform float _ColorVariation;
					uniform half _Hue;
					uniform float4 _Color;
					uniform sampler2D _MainTex;
					uniform float4 _MainTex_ST;
					uniform float _Saturation;
					uniform float _Value;
					uniform int _ColorShifting;
					uniform float _Metallic;
					uniform float _Glossiness;
					uniform half _OcclusionStrength;
					uniform float4 _TransmissionTint;
					uniform half _Translucency;
					uniform half _TransNormalDistortion;
					uniform half _TransScattering;
					uniform half _TransDirect;
					uniform half _TransAmbient;
					uniform half _TransShadow;
					uniform float4 _TranslucencyTint;
					uniform half _Cutoff;


					float2 DirectionalEquation(float _WindDirection)
					{
						float d = _WindDirection * 0.0174532924;
						float xL = cos(d) + 1 / 2;
						float zL = sin(d) + 1 / 2;
						return float2(zL,xL);
					}


					float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
					{
						float3 Output = m_None;
						if (m_Switch == 0) { Output = m_Leaves; }
						if (m_Switch == 1) { Output = m_Palm; }
						if (m_Switch == 2) { Output = m_Grass; }
						if (m_Switch == 3) { Output = m_None; }
						return Output;
					}


					float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
					{
						float3 OUT = None;
						if (Cull == 0) {
							if (Mode == 0)
								OUT = Flip;
							if (Mode == 1)
								OUT = Mirror;
							if (Mode == 2)
								OUT == None;
						}
			else {
			   OUT = None;
		   }
		   return OUT;
	   }


	   float3 HSVToRGB(float3 c)
	   {
		   float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
		   float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
		   return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
	   }


	   float3 RGBToHSV(float3 c)
	   {
		   float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
		   float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
		   float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
		   float d = q.x - min(q.w, q.y);
		   float e = 1.0e-10;
		   return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
	   }

	   inline float Dither8x8Bayer(int x, int y)
	   {
		   const float dither[64] = {
				1, 49, 13, 61,  4, 52, 16, 64,
			   33, 17, 45, 29, 36, 20, 48, 32,
				9, 57,  5, 53, 12, 60,  8, 56,
			   41, 25, 37, 21, 44, 28, 40, 24,
				3, 51, 15, 63,  2, 50, 14, 62,
			   35, 19, 47, 31, 34, 18, 46, 30,
			   11, 59,  7, 55, 10, 58,  6, 54,
			   43, 27, 39, 23, 42, 26, 38, 22};
		   int r = y * 8 + x;
		   return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
	   }


	   void vertexDataFunc(inout appdata_full v, out Input o)
	   {
		   UNITY_INITIALIZE_OUTPUT(Input, o);
		   int m_Switch252_g490 = _WindModeLeaves;
		   float3 ase_vertex3Pos = v.vertex.xyz;
		   float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
		   float3 break109_g490 = VAR_VertexPosition21_g490;
		   float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
		   float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
		   float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
		   float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
		   float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
		   float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
		   float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
		   float VAR_WindPulse274_g490 = _WindPulse;
		   float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
		   float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
		   float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
		   float _WindDirection164_g490 = _WindDirection;
		   float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
		   float2 break165_g490 = localDirectionalEquation164_g490;
		   float VAR_xLerp83_g490 = break165_g490.x;
		   float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
		   float3 break98_g490 = VAR_VertexPosition21_g490;
		   float3 break105_g490 = VAR_VertexPosition21_g490;
		   float VAR_zLerp95_g490 = break165_g490.y;
		   float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
		   float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
		   float3 FUNC_vertexPos123_g490 = appendResult122_g490;
		   float3 break236_g490 = FUNC_vertexPos123_g490;
		   half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
		   float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
		   float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
		   float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
		   float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
		   float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
		   float3 ase_normWorldNormal = normalize(ase_worldNormal);
		   float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
		   float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
		   float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
		   float3 break221_g490 = FUNC_vertexPos123_g490;
		   float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
		   float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
		   float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
		   float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
		   float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
		   float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
		   float3 m_None252_g490 = FUNC_vertexPos123_g490;
		   float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
		   float3 OUT_Leafs262_g490 = localIf252_g490;
		   float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
		   float3 OUT_VertexPos261 = temp_output_5_0_g490;
		   v.vertex.xyz = OUT_VertexPos261;
		   float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
		   o.screenPosition = ase_screenPos;
	   }

	   inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
	   {
		   #if !DIRECTIONAL
		   float3 lightAtten = gi.light.color;
		   #else
		   float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
		   #endif
		   half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
		   half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
		   half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
		   half4 c = half4(s.Albedo * translucency * _Translucency, 0);

		   half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
		   half4 d = half4(s.Albedo * transmission , 0);

		   SurfaceOutputStandard r;
		   r.Albedo = s.Albedo;
		   r.Normal = s.Normal;
		   r.Emission = s.Emission;
		   r.Metallic = s.Metallic;
		   r.Smoothness = s.Smoothness;
		   r.Occlusion = s.Occlusion;
		   r.Alpha = s.Alpha;
		   return LightingStandard(r, viewDir, gi) + c + d;
	   }

	   inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
	   {
		   #if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
			   gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
		   #else
			   UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
			   gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
		   #endif
	   }

	   void surf(Input i , inout SurfaceOutputStandardCustom o)
	   {
		   float Mode4_g488 = (float)_DoubleSidedNormalMode;
		   float Cull4_g488 = (float)_CullMode;
		   float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
		   float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
		   float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
		   float3 break7_g488 = bump5_g488;
		   float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
		   float3 Mirror4_g488 = appendResult11_g488;
		   float3 None4_g488 = bump5_g488;
		   float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
		   float3 OUT_Normal255 = localIf4_g488;
		   o.Normal = OUT_Normal255;
		   float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
		   float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
		   float4 VAR_AlbedoTexture267 = tex2DNode13;
		   float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
		   float4 VAR_Albedo18_g489 = VAR_Albedo101;
		   float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
		   float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
		   float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
		   float4 OUT_Albedo254 = lerpResult19_g489;
		   o.Albedo = OUT_Albedo254.rgb;
		   o.Metallic = _Metallic;
		   float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
		   float OUT_Smoothness50 = lerpResult268;
		   o.Smoothness = OUT_Smoothness50;
		   float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
		   float OUT_AO44 = lerpResult41;
		   o.Occlusion = OUT_AO44;
		   float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
		   #if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
		   float4 ase_lightColor = 0;
		   #else //aselc
		   float4 ase_lightColor = _LightColor0;
		   #endif //aselc
		   float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
		   float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
		   o.Transmission = OUT_Transmission350;
		   float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
		   o.Translucency = OUT_Translucency275;
		   clip(tex2DNode13.a - _Cutoff);
		   float temp_output_41_0_g487 = tex2DNode13.a;
		   float4 ase_screenPos = i.screenPosition;
		   float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
		   ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
		   float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
		   float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
		   dither45_g487 = step(dither45_g487, unity_LODFade.x);
		   #ifdef LOD_FADE_CROSSFADE
			   float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
		   #else
			   float staticSwitch40_g487 = temp_output_41_0_g487;
		   #endif
		   float OUT_Alpha46 = staticSwitch40_g487;
		   o.Alpha = OUT_Alpha46;
	   }



	   // vertex-to-fragment interpolation data
	   // no lightmaps:
	   #ifndef LIGHTMAP_ON
	   // half-precision fragment shader registers:
	   #ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
	   #define FOG_COMBINED_WITH_TSPACE
	   struct v2f_surf {
		 UNITY_POSITION(pos);
		 float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
		 float4 tSpace0 : TEXCOORD1;
		 float4 tSpace1 : TEXCOORD2;
		 float4 tSpace2 : TEXCOORD3;
		 fixed4 color : COLOR0;
		 float4 custompack0 : TEXCOORD4; // screenPosition
		 #if UNITY_SHOULD_SAMPLE_SH
		 half3 sh : TEXCOORD5; // SH
		 #endif
		 UNITY_LIGHTING_COORDS(6,7)
		 #if SHADER_TARGET >= 30
		 float4 lmap : TEXCOORD8;
		 #endif
		 UNITY_VERTEX_INPUT_INSTANCE_ID
		 UNITY_VERTEX_OUTPUT_STEREO
	   };
	   #endif
	   // high-precision fragment shader registers:
	   #ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
	   struct v2f_surf {
		 UNITY_POSITION(pos);
		 float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
		 float4 tSpace0 : TEXCOORD1;
		 float4 tSpace1 : TEXCOORD2;
		 float4 tSpace2 : TEXCOORD3;
		 fixed4 color : COLOR0;
		 float4 custompack0 : TEXCOORD4; // screenPosition
		 #if UNITY_SHOULD_SAMPLE_SH
		 half3 sh : TEXCOORD5; // SH
		 #endif
		 UNITY_FOG_COORDS(6)
		 UNITY_SHADOW_COORDS(7)
		 #if SHADER_TARGET >= 30
		 float4 lmap : TEXCOORD8;
		 #endif
		 UNITY_VERTEX_INPUT_INSTANCE_ID
		 UNITY_VERTEX_OUTPUT_STEREO
	   };
	   #endif
	   #endif
	   // with lightmaps:
	   #ifdef LIGHTMAP_ON
	   // half-precision fragment shader registers:
	   #ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
	   #define FOG_COMBINED_WITH_TSPACE
	   struct v2f_surf {
		 UNITY_POSITION(pos);
		 float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
		 float4 tSpace0 : TEXCOORD1;
		 float4 tSpace1 : TEXCOORD2;
		 float4 tSpace2 : TEXCOORD3;
		 fixed4 color : COLOR0;
		 float4 custompack0 : TEXCOORD4; // screenPosition
		 float4 lmap : TEXCOORD5;
		 UNITY_LIGHTING_COORDS(6,7)
		 UNITY_VERTEX_INPUT_INSTANCE_ID
		 UNITY_VERTEX_OUTPUT_STEREO
	   };
	   #endif
	   // high-precision fragment shader registers:
	   #ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
	   struct v2f_surf {
		 UNITY_POSITION(pos);
		 float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
		 float4 tSpace0 : TEXCOORD1;
		 float4 tSpace1 : TEXCOORD2;
		 float4 tSpace2 : TEXCOORD3;
		 fixed4 color : COLOR0;
		 float4 custompack0 : TEXCOORD4; // screenPosition
		 float4 lmap : TEXCOORD5;
		 UNITY_FOG_COORDS(6)
		 UNITY_SHADOW_COORDS(7)
		 UNITY_VERTEX_INPUT_INSTANCE_ID
		 UNITY_VERTEX_OUTPUT_STEREO
	   };
	   #endif
	   #endif
	   float4 _texcoord_ST;
	   float4 _texcoord4_ST;

	   // vertex shader
	   v2f_surf vert_surf(appdata_full v) {
		 UNITY_SETUP_INSTANCE_ID(v);
		 v2f_surf o;
		 UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
		 UNITY_TRANSFER_INSTANCE_ID(v,o);
		 UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
		 Input customInputData;
		 vertexDataFunc(v, customInputData);
		 o.custompack0.xyzw = customInputData.screenPosition;
		 o.pos = UnityObjectToClipPos(v.vertex);
		 o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
		 o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
		 float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
		 float3 worldNormal = UnityObjectToWorldNormal(v.normal);
		 fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
		 fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
		 fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
		 o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
		 o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
		 o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
		 o.color = v.color;
		 #ifdef DYNAMICLIGHTMAP_ON
		 o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
		 #endif
		 #ifdef LIGHTMAP_ON
		 o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
		 #endif

		 // SH/ambient and vertex lights
		 #ifndef LIGHTMAP_ON
		   #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
			 o.sh = 0;
			 // Approximated illumination from non-important point lights
			 #ifdef VERTEXLIGHT_ON
			   o.sh += Shade4PointLights(
				 unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
				 unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
				 unity_4LightAtten0, worldPos, worldNormal);
			 #endif
			 o.sh = ShadeSHPerVertex(worldNormal, o.sh);
		   #endif
		 #endif // !LIGHTMAP_ON

		 UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
		 #ifdef FOG_COMBINED_WITH_TSPACE
		   UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
		 #elif defined (FOG_COMBINED_WITH_WORLD_POS)
		   UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
		 #else
		   UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
		 #endif
		 return o;
	   }

	   // fragment shader
	   fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
		 UNITY_SETUP_INSTANCE_ID(IN);
	   // prepare and unpack data
	   Input surfIN;
	   #ifdef FOG_COMBINED_WITH_TSPACE
		 UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
	   #elif defined (FOG_COMBINED_WITH_WORLD_POS)
		 UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
	   #else
		 UNITY_EXTRACT_FOG(IN);
	   #endif
	   #ifdef FOG_COMBINED_WITH_TSPACE
		 UNITY_RECONSTRUCT_TBN(IN);
	   #else
		 UNITY_EXTRACT_TBN(IN);
	   #endif
	   UNITY_INITIALIZE_OUTPUT(Input,surfIN);
	   surfIN.uv_texcoord.x = 1.0;
	   surfIN.ASEVFace.x = 1.0;
	   surfIN.vertexColor.x = 1.0;
	   surfIN.uv4_texcoord4.x = 1.0;
	   surfIN.screenPosition.x = 1.0;
	   surfIN.uv_texcoord = IN.pack0.xy;
	   surfIN.uv4_texcoord4 = IN.pack0.zw;
	   surfIN.screenPosition = IN.custompack0.xyzw;
	   float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
	   #ifndef USING_DIRECTIONAL_LIGHT
		 fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
	   #else
		 fixed3 lightDir = _WorldSpaceLightPos0.xyz;
	   #endif
	   float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
	   surfIN.vertexColor = IN.color;
	   #if UNITY_VFACE_FLIPPED
		  vface = -vface;
	   #endif
	   surfIN.ASEVFace = vface;
	   #ifdef UNITY_COMPILER_HLSL
	   SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
	   #else
	   SurfaceOutputStandardCustom o;
	   #endif
	   o.Albedo = 0.0;
	   o.Emission = 0.0;
	   o.Alpha = 0.0;
	   o.Occlusion = 1.0;
	   fixed3 normalWorldVertex = fixed3(0,0,1);
	   o.Normal = fixed3(0,0,1);

	   // call surface function
	   surf(surfIN, o);

	   // compute lighting & shadowing factor
	   UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
	   fixed4 c = 0;
	   float3 worldN;
	   worldN.x = dot(_unity_tbn_0, o.Normal);
	   worldN.y = dot(_unity_tbn_1, o.Normal);
	   worldN.z = dot(_unity_tbn_2, o.Normal);
	   worldN = normalize(worldN);
	   o.Normal = worldN;

	   // Setup lighting environment
	   UnityGI gi;
	   UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
	   gi.indirect.diffuse = 0;
	   gi.indirect.specular = 0;
	   gi.light.color = _LightColor0.rgb;
	   gi.light.dir = lightDir;
	   // Call GI (lightmaps/SH/reflections) lighting function
	   UnityGIInput giInput;
	   UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
	   giInput.light = gi.light;
	   giInput.worldPos = worldPos;
	   giInput.worldViewDir = worldViewDir;
	   giInput.atten = atten;
	   #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
		 giInput.lightmapUV = IN.lmap;
	   #else
		 giInput.lightmapUV = 0.0;
	   #endif
	   #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
		 giInput.ambient = IN.sh;
	   #else
		 giInput.ambient.rgb = 0.0;
	   #endif
	   giInput.probeHDR[0] = unity_SpecCube0_HDR;
	   giInput.probeHDR[1] = unity_SpecCube1_HDR;
	   #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
		 giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
	   #endif
	   #ifdef UNITY_SPECCUBE_BOX_PROJECTION
		 giInput.boxMax[0] = unity_SpecCube0_BoxMax;
		 giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
		 giInput.boxMax[1] = unity_SpecCube1_BoxMax;
		 giInput.boxMin[1] = unity_SpecCube1_BoxMin;
		 giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
	   #endif
	   LightingStandardCustom_GI(o, giInput, gi);

	   // realtime lighting: call lighting function
	   c += LightingStandardCustom(o, worldViewDir, gi);
	   UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
	   return c;
	 }


	 #endif

		   // -------- variant for: INSTANCING_ON 
		   #if defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_GLOSSYREFLECTIONS_OFF) && !defined(_SPECULARHIGHLIGHTS_OFF)
		   // Surface shader code generated based on:
		   // vertex modifier: 'vertexDataFunc'
		   // writes to per-pixel normal: YES
		   // writes to emission: no
		   // writes to occlusion: YES
		   // needs world space reflection vector: no
		   // needs world space normal vector: no
		   // needs screen space position: no
		   // needs world space position: no
		   // needs view direction: no
		   // needs world space view direction: no
		   // needs world space position for lighting: YES
		   // needs world space view direction for lighting: YES
		   // needs world space view direction for lightmaps: no
		   // needs vertex color: YES
		   // needs VFACE: YES
		   // passes tangent-to-world matrix to pixel shader: YES
		   // reads from normal: no
		   // 2 texcoords actually used
		   //   float2 _texcoord
		   //   float2 _texcoord4
		   #include "UnityCG.cginc"
		   #include "Lighting.cginc"
		   #include "AutoLight.cginc"

		   #define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
		   #define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
		   #define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

		   // Original surface shader snippet:
		   #line 48 ""
		   #ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
		   #endif
		   /* UNITY: Original start of shader */
				   #include "UnityShaderVariables.cginc"
				   #include "UnityStandardUtils.cginc"
				   #include "UnityPBSLighting.cginc"
				   //#pragma target 3.0
				   //#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
				   //#pragma shader_feature _GLOSSYREFLECTIONS_OFF
				   //#pragma multi_compile __ LOD_FADE_CROSSFADE
				   //#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
				   struct Input
				   {
					   float2 uv_texcoord;
					   half ASEVFace : VFACE;
					   float4 vertexColor : COLOR;
					   float2 uv4_texcoord4;
					   float4 screenPosition;
				   };

				   struct SurfaceOutputStandardCustom
				   {
					   half3 Albedo;
					   half3 Normal;
					   half3 Emission;
					   half Metallic;
					   half Smoothness;
					   half Occlusion;
					   half Alpha;
					   half3 Transmission;
					   half3 Translucency;
				   };

				   uniform int _WindModeLeaves;
				   uniform float _WindStrength;
				   uniform float _GlobalWindInfluence;
				   uniform float _RandomWindOffset;
				   uniform float _WindPulse;
				   uniform float _WindDirection;
				   uniform float _WindTurbulence;
				   uniform float _GlobalTurbulenceInfluence;
				   uniform int _DoubleSidedNormalMode;
				   uniform int _CullMode;
				   uniform sampler2D _BumpMap;
				   uniform float4 _BumpMap_ST;
				   uniform half _BumpScale;
				   uniform float _ColorVariation;
				   uniform half _Hue;
				   uniform float4 _Color;
				   uniform sampler2D _MainTex;
				   uniform float4 _MainTex_ST;
				   uniform float _Saturation;
				   uniform float _Value;
				   uniform int _ColorShifting;
				   uniform float _Metallic;
				   uniform float _Glossiness;
				   uniform half _OcclusionStrength;
				   uniform float4 _TransmissionTint;
				   uniform half _Translucency;
				   uniform half _TransNormalDistortion;
				   uniform half _TransScattering;
				   uniform half _TransDirect;
				   uniform half _TransAmbient;
				   uniform half _TransShadow;
				   uniform float4 _TranslucencyTint;
				   uniform half _Cutoff;


				   float2 DirectionalEquation(float _WindDirection)
				   {
					   float d = _WindDirection * 0.0174532924;
					   float xL = cos(d) + 1 / 2;
					   float zL = sin(d) + 1 / 2;
					   return float2(zL,xL);
				   }


				   float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
				   {
					   float3 Output = m_None;
					   if (m_Switch == 0) { Output = m_Leaves; }
					   if (m_Switch == 1) { Output = m_Palm; }
					   if (m_Switch == 2) { Output = m_Grass; }
					   if (m_Switch == 3) { Output = m_None; }
					   return Output;
				   }


				   float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
				   {
					   float3 OUT = None;
					   if (Cull == 0) {
						   if (Mode == 0)
							   OUT = Flip;
						   if (Mode == 1)
							   OUT = Mirror;
						   if (Mode == 2)
							   OUT == None;
					   }
		   else {
			  OUT = None;
		  }
		  return OUT;
	  }


	  float3 HSVToRGB(float3 c)
	  {
		  float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
		  float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
		  return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
	  }


	  float3 RGBToHSV(float3 c)
	  {
		  float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
		  float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
		  float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
		  float d = q.x - min(q.w, q.y);
		  float e = 1.0e-10;
		  return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
	  }

	  inline float Dither8x8Bayer(int x, int y)
	  {
		  const float dither[64] = {
			   1, 49, 13, 61,  4, 52, 16, 64,
			  33, 17, 45, 29, 36, 20, 48, 32,
			   9, 57,  5, 53, 12, 60,  8, 56,
			  41, 25, 37, 21, 44, 28, 40, 24,
			   3, 51, 15, 63,  2, 50, 14, 62,
			  35, 19, 47, 31, 34, 18, 46, 30,
			  11, 59,  7, 55, 10, 58,  6, 54,
			  43, 27, 39, 23, 42, 26, 38, 22};
		  int r = y * 8 + x;
		  return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
	  }


	  void vertexDataFunc(inout appdata_full v, out Input o)
	  {
		  UNITY_INITIALIZE_OUTPUT(Input, o);
		  int m_Switch252_g490 = _WindModeLeaves;
		  float3 ase_vertex3Pos = v.vertex.xyz;
		  float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
		  float3 break109_g490 = VAR_VertexPosition21_g490;
		  float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
		  float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
		  float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
		  float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
		  float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
		  float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
		  float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
		  float VAR_WindPulse274_g490 = _WindPulse;
		  float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
		  float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
		  float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
		  float _WindDirection164_g490 = _WindDirection;
		  float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
		  float2 break165_g490 = localDirectionalEquation164_g490;
		  float VAR_xLerp83_g490 = break165_g490.x;
		  float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
		  float3 break98_g490 = VAR_VertexPosition21_g490;
		  float3 break105_g490 = VAR_VertexPosition21_g490;
		  float VAR_zLerp95_g490 = break165_g490.y;
		  float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
		  float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
		  float3 FUNC_vertexPos123_g490 = appendResult122_g490;
		  float3 break236_g490 = FUNC_vertexPos123_g490;
		  half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
		  float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
		  float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
		  float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
		  float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
		  float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
		  float3 ase_normWorldNormal = normalize(ase_worldNormal);
		  float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
		  float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
		  float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
		  float3 break221_g490 = FUNC_vertexPos123_g490;
		  float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
		  float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
		  float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
		  float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
		  float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
		  float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
		  float3 m_None252_g490 = FUNC_vertexPos123_g490;
		  float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
		  float3 OUT_Leafs262_g490 = localIf252_g490;
		  float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
		  float3 OUT_VertexPos261 = temp_output_5_0_g490;
		  v.vertex.xyz = OUT_VertexPos261;
		  float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
		  o.screenPosition = ase_screenPos;
	  }

	  inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
	  {
		  #if !DIRECTIONAL
		  float3 lightAtten = gi.light.color;
		  #else
		  float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
		  #endif
		  half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
		  half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
		  half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
		  half4 c = half4(s.Albedo * translucency * _Translucency, 0);

		  half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
		  half4 d = half4(s.Albedo * transmission , 0);

		  SurfaceOutputStandard r;
		  r.Albedo = s.Albedo;
		  r.Normal = s.Normal;
		  r.Emission = s.Emission;
		  r.Metallic = s.Metallic;
		  r.Smoothness = s.Smoothness;
		  r.Occlusion = s.Occlusion;
		  r.Alpha = s.Alpha;
		  return LightingStandard(r, viewDir, gi) + c + d;
	  }

	  inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
	  {
		  #if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
			  gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
		  #else
			  UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
			  gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
		  #endif
	  }

	  void surf(Input i , inout SurfaceOutputStandardCustom o)
	  {
		  float Mode4_g488 = (float)_DoubleSidedNormalMode;
		  float Cull4_g488 = (float)_CullMode;
		  float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
		  float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
		  float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
		  float3 break7_g488 = bump5_g488;
		  float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
		  float3 Mirror4_g488 = appendResult11_g488;
		  float3 None4_g488 = bump5_g488;
		  float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
		  float3 OUT_Normal255 = localIf4_g488;
		  o.Normal = OUT_Normal255;
		  float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
		  float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
		  float4 VAR_AlbedoTexture267 = tex2DNode13;
		  float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
		  float4 VAR_Albedo18_g489 = VAR_Albedo101;
		  float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
		  float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
		  float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
		  float4 OUT_Albedo254 = lerpResult19_g489;
		  o.Albedo = OUT_Albedo254.rgb;
		  o.Metallic = _Metallic;
		  float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
		  float OUT_Smoothness50 = lerpResult268;
		  o.Smoothness = OUT_Smoothness50;
		  float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
		  float OUT_AO44 = lerpResult41;
		  o.Occlusion = OUT_AO44;
		  float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
		  #if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
		  float4 ase_lightColor = 0;
		  #else //aselc
		  float4 ase_lightColor = _LightColor0;
		  #endif //aselc
		  float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
		  float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
		  o.Transmission = OUT_Transmission350;
		  float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
		  o.Translucency = OUT_Translucency275;
		  clip(tex2DNode13.a - _Cutoff);
		  float temp_output_41_0_g487 = tex2DNode13.a;
		  float4 ase_screenPos = i.screenPosition;
		  float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
		  ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
		  float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
		  float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
		  dither45_g487 = step(dither45_g487, unity_LODFade.x);
		  #ifdef LOD_FADE_CROSSFADE
			  float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
		  #else
			  float staticSwitch40_g487 = temp_output_41_0_g487;
		  #endif
		  float OUT_Alpha46 = staticSwitch40_g487;
		  o.Alpha = OUT_Alpha46;
	  }



	  // vertex-to-fragment interpolation data
	  // no lightmaps:
	  #ifndef LIGHTMAP_ON
	  // half-precision fragment shader registers:
	  #ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
	  #define FOG_COMBINED_WITH_TSPACE
	  struct v2f_surf {
		UNITY_POSITION(pos);
		float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
		float4 tSpace0 : TEXCOORD1;
		float4 tSpace1 : TEXCOORD2;
		float4 tSpace2 : TEXCOORD3;
		fixed4 color : COLOR0;
		float4 custompack0 : TEXCOORD4; // screenPosition
		#if UNITY_SHOULD_SAMPLE_SH
		half3 sh : TEXCOORD5; // SH
		#endif
		UNITY_LIGHTING_COORDS(6,7)
		#if SHADER_TARGET >= 30
		float4 lmap : TEXCOORD8;
		#endif
		UNITY_VERTEX_INPUT_INSTANCE_ID
		UNITY_VERTEX_OUTPUT_STEREO
	  };
	  #endif
	  // high-precision fragment shader registers:
	  #ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
	  struct v2f_surf {
		UNITY_POSITION(pos);
		float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
		float4 tSpace0 : TEXCOORD1;
		float4 tSpace1 : TEXCOORD2;
		float4 tSpace2 : TEXCOORD3;
		fixed4 color : COLOR0;
		float4 custompack0 : TEXCOORD4; // screenPosition
		#if UNITY_SHOULD_SAMPLE_SH
		half3 sh : TEXCOORD5; // SH
		#endif
		UNITY_FOG_COORDS(6)
		UNITY_SHADOW_COORDS(7)
		#if SHADER_TARGET >= 30
		float4 lmap : TEXCOORD8;
		#endif
		UNITY_VERTEX_INPUT_INSTANCE_ID
		UNITY_VERTEX_OUTPUT_STEREO
	  };
	  #endif
	  #endif
	  // with lightmaps:
	  #ifdef LIGHTMAP_ON
	  // half-precision fragment shader registers:
	  #ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
	  #define FOG_COMBINED_WITH_TSPACE
	  struct v2f_surf {
		UNITY_POSITION(pos);
		float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
		float4 tSpace0 : TEXCOORD1;
		float4 tSpace1 : TEXCOORD2;
		float4 tSpace2 : TEXCOORD3;
		fixed4 color : COLOR0;
		float4 custompack0 : TEXCOORD4; // screenPosition
		float4 lmap : TEXCOORD5;
		UNITY_LIGHTING_COORDS(6,7)
		UNITY_VERTEX_INPUT_INSTANCE_ID
		UNITY_VERTEX_OUTPUT_STEREO
	  };
	  #endif
	  // high-precision fragment shader registers:
	  #ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
	  struct v2f_surf {
		UNITY_POSITION(pos);
		float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
		float4 tSpace0 : TEXCOORD1;
		float4 tSpace1 : TEXCOORD2;
		float4 tSpace2 : TEXCOORD3;
		fixed4 color : COLOR0;
		float4 custompack0 : TEXCOORD4; // screenPosition
		float4 lmap : TEXCOORD5;
		UNITY_FOG_COORDS(6)
		UNITY_SHADOW_COORDS(7)
		UNITY_VERTEX_INPUT_INSTANCE_ID
		UNITY_VERTEX_OUTPUT_STEREO
	  };
	  #endif
	  #endif
	  float4 _texcoord_ST;
	  float4 _texcoord4_ST;

	  // vertex shader
	  v2f_surf vert_surf(appdata_full v) {
		UNITY_SETUP_INSTANCE_ID(v);
		v2f_surf o;
		UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
		UNITY_TRANSFER_INSTANCE_ID(v,o);
		UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
		Input customInputData;
		vertexDataFunc(v, customInputData);
		o.custompack0.xyzw = customInputData.screenPosition;
		o.pos = UnityObjectToClipPos(v.vertex);
		o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
		o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
		float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
		float3 worldNormal = UnityObjectToWorldNormal(v.normal);
		fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
		fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
		fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
		o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
		o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
		o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
		o.color = v.color;
		#ifdef DYNAMICLIGHTMAP_ON
		o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
		#endif
		#ifdef LIGHTMAP_ON
		o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
		#endif

		// SH/ambient and vertex lights
		#ifndef LIGHTMAP_ON
		  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
			o.sh = 0;
			// Approximated illumination from non-important point lights
			#ifdef VERTEXLIGHT_ON
			  o.sh += Shade4PointLights(
				unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
				unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
				unity_4LightAtten0, worldPos, worldNormal);
			#endif
			o.sh = ShadeSHPerVertex(worldNormal, o.sh);
		  #endif
		#endif // !LIGHTMAP_ON

		UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
		#ifdef FOG_COMBINED_WITH_TSPACE
		  UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
		#elif defined (FOG_COMBINED_WITH_WORLD_POS)
		  UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
		#else
		  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
		#endif
		return o;
	  }

	  // fragment shader
	  fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
		UNITY_SETUP_INSTANCE_ID(IN);
	  // prepare and unpack data
	  Input surfIN;
	  #ifdef FOG_COMBINED_WITH_TSPACE
		UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
	  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
		UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
	  #else
		UNITY_EXTRACT_FOG(IN);
	  #endif
	  #ifdef FOG_COMBINED_WITH_TSPACE
		UNITY_RECONSTRUCT_TBN(IN);
	  #else
		UNITY_EXTRACT_TBN(IN);
	  #endif
	  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
	  surfIN.uv_texcoord.x = 1.0;
	  surfIN.ASEVFace.x = 1.0;
	  surfIN.vertexColor.x = 1.0;
	  surfIN.uv4_texcoord4.x = 1.0;
	  surfIN.screenPosition.x = 1.0;
	  surfIN.uv_texcoord = IN.pack0.xy;
	  surfIN.uv4_texcoord4 = IN.pack0.zw;
	  surfIN.screenPosition = IN.custompack0.xyzw;
	  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
	  #ifndef USING_DIRECTIONAL_LIGHT
		fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
	  #else
		fixed3 lightDir = _WorldSpaceLightPos0.xyz;
	  #endif
	  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
	  surfIN.vertexColor = IN.color;
	  #if UNITY_VFACE_FLIPPED
		 vface = -vface;
	  #endif
	  surfIN.ASEVFace = vface;
	  #ifdef UNITY_COMPILER_HLSL
	  SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
	  #else
	  SurfaceOutputStandardCustom o;
	  #endif
	  o.Albedo = 0.0;
	  o.Emission = 0.0;
	  o.Alpha = 0.0;
	  o.Occlusion = 1.0;
	  fixed3 normalWorldVertex = fixed3(0,0,1);
	  o.Normal = fixed3(0,0,1);

	  // call surface function
	  surf(surfIN, o);

	  // compute lighting & shadowing factor
	  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
	  fixed4 c = 0;
	  float3 worldN;
	  worldN.x = dot(_unity_tbn_0, o.Normal);
	  worldN.y = dot(_unity_tbn_1, o.Normal);
	  worldN.z = dot(_unity_tbn_2, o.Normal);
	  worldN = normalize(worldN);
	  o.Normal = worldN;

	  // Setup lighting environment
	  UnityGI gi;
	  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
	  gi.indirect.diffuse = 0;
	  gi.indirect.specular = 0;
	  gi.light.color = _LightColor0.rgb;
	  gi.light.dir = lightDir;
	  // Call GI (lightmaps/SH/reflections) lighting function
	  UnityGIInput giInput;
	  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
	  giInput.light = gi.light;
	  giInput.worldPos = worldPos;
	  giInput.worldViewDir = worldViewDir;
	  giInput.atten = atten;
	  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
		giInput.lightmapUV = IN.lmap;
	  #else
		giInput.lightmapUV = 0.0;
	  #endif
	  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
		giInput.ambient = IN.sh;
	  #else
		giInput.ambient.rgb = 0.0;
	  #endif
	  giInput.probeHDR[0] = unity_SpecCube0_HDR;
	  giInput.probeHDR[1] = unity_SpecCube1_HDR;
	  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
		giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
	  #endif
	  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
		giInput.boxMax[0] = unity_SpecCube0_BoxMax;
		giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
		giInput.boxMax[1] = unity_SpecCube1_BoxMax;
		giInput.boxMin[1] = unity_SpecCube1_BoxMin;
		giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
	  #endif
	  LightingStandardCustom_GI(o, giInput, gi);

	  // realtime lighting: call lighting function
	  c += LightingStandardCustom(o, worldViewDir, gi);
	  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
	  return c;
	}


	#endif

		  // -------- variant for: LOD_FADE_CROSSFADE 
		  #if defined(LOD_FADE_CROSSFADE) && !defined(INSTANCING_ON) && !defined(_GLOSSYREFLECTIONS_OFF) && !defined(_SPECULARHIGHLIGHTS_OFF)
		  // Surface shader code generated based on:
		  // vertex modifier: 'vertexDataFunc'
		  // writes to per-pixel normal: YES
		  // writes to emission: no
		  // writes to occlusion: YES
		  // needs world space reflection vector: no
		  // needs world space normal vector: no
		  // needs screen space position: no
		  // needs world space position: no
		  // needs view direction: no
		  // needs world space view direction: no
		  // needs world space position for lighting: YES
		  // needs world space view direction for lighting: YES
		  // needs world space view direction for lightmaps: no
		  // needs vertex color: YES
		  // needs VFACE: YES
		  // passes tangent-to-world matrix to pixel shader: YES
		  // reads from normal: no
		  // 2 texcoords actually used
		  //   float2 _texcoord
		  //   float2 _texcoord4
		  #include "UnityCG.cginc"
		  #include "Lighting.cginc"
		  #include "AutoLight.cginc"

		  #define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
		  #define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
		  #define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

		  // Original surface shader snippet:
		  #line 48 ""
		  #ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
		  #endif
		  /* UNITY: Original start of shader */
				  #include "UnityShaderVariables.cginc"
				  #include "UnityStandardUtils.cginc"
				  #include "UnityPBSLighting.cginc"
				  //#pragma target 3.0
				  //#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
				  //#pragma shader_feature _GLOSSYREFLECTIONS_OFF
				  //#pragma multi_compile __ LOD_FADE_CROSSFADE
				  //#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
				  struct Input
				  {
					  float2 uv_texcoord;
					  half ASEVFace : VFACE;
					  float4 vertexColor : COLOR;
					  float2 uv4_texcoord4;
					  float4 screenPosition;
				  };

				  struct SurfaceOutputStandardCustom
				  {
					  half3 Albedo;
					  half3 Normal;
					  half3 Emission;
					  half Metallic;
					  half Smoothness;
					  half Occlusion;
					  half Alpha;
					  half3 Transmission;
					  half3 Translucency;
				  };

				  uniform int _WindModeLeaves;
				  uniform float _WindStrength;
				  uniform float _GlobalWindInfluence;
				  uniform float _RandomWindOffset;
				  uniform float _WindPulse;
				  uniform float _WindDirection;
				  uniform float _WindTurbulence;
				  uniform float _GlobalTurbulenceInfluence;
				  uniform int _DoubleSidedNormalMode;
				  uniform int _CullMode;
				  uniform sampler2D _BumpMap;
				  uniform float4 _BumpMap_ST;
				  uniform half _BumpScale;
				  uniform float _ColorVariation;
				  uniform half _Hue;
				  uniform float4 _Color;
				  uniform sampler2D _MainTex;
				  uniform float4 _MainTex_ST;
				  uniform float _Saturation;
				  uniform float _Value;
				  uniform int _ColorShifting;
				  uniform float _Metallic;
				  uniform float _Glossiness;
				  uniform half _OcclusionStrength;
				  uniform float4 _TransmissionTint;
				  uniform half _Translucency;
				  uniform half _TransNormalDistortion;
				  uniform half _TransScattering;
				  uniform half _TransDirect;
				  uniform half _TransAmbient;
				  uniform half _TransShadow;
				  uniform float4 _TranslucencyTint;
				  uniform half _Cutoff;


				  float2 DirectionalEquation(float _WindDirection)
				  {
					  float d = _WindDirection * 0.0174532924;
					  float xL = cos(d) + 1 / 2;
					  float zL = sin(d) + 1 / 2;
					  return float2(zL,xL);
				  }


				  float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
				  {
					  float3 Output = m_None;
					  if (m_Switch == 0) { Output = m_Leaves; }
					  if (m_Switch == 1) { Output = m_Palm; }
					  if (m_Switch == 2) { Output = m_Grass; }
					  if (m_Switch == 3) { Output = m_None; }
					  return Output;
				  }


				  float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
				  {
					  float3 OUT = None;
					  if (Cull == 0) {
						  if (Mode == 0)
							  OUT = Flip;
						  if (Mode == 1)
							  OUT = Mirror;
						  if (Mode == 2)
							  OUT == None;
					  }
		  else {
			 OUT = None;
		 }
		 return OUT;
	 }


	 float3 HSVToRGB(float3 c)
	 {
		 float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
		 float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
		 return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
	 }


	 float3 RGBToHSV(float3 c)
	 {
		 float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
		 float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
		 float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
		 float d = q.x - min(q.w, q.y);
		 float e = 1.0e-10;
		 return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
	 }

	 inline float Dither8x8Bayer(int x, int y)
	 {
		 const float dither[64] = {
			  1, 49, 13, 61,  4, 52, 16, 64,
			 33, 17, 45, 29, 36, 20, 48, 32,
			  9, 57,  5, 53, 12, 60,  8, 56,
			 41, 25, 37, 21, 44, 28, 40, 24,
			  3, 51, 15, 63,  2, 50, 14, 62,
			 35, 19, 47, 31, 34, 18, 46, 30,
			 11, 59,  7, 55, 10, 58,  6, 54,
			 43, 27, 39, 23, 42, 26, 38, 22};
		 int r = y * 8 + x;
		 return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
	 }


	 void vertexDataFunc(inout appdata_full v, out Input o)
	 {
		 UNITY_INITIALIZE_OUTPUT(Input, o);
		 int m_Switch252_g490 = _WindModeLeaves;
		 float3 ase_vertex3Pos = v.vertex.xyz;
		 float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
		 float3 break109_g490 = VAR_VertexPosition21_g490;
		 float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
		 float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
		 float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
		 float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
		 float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
		 float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
		 float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
		 float VAR_WindPulse274_g490 = _WindPulse;
		 float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
		 float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
		 float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
		 float _WindDirection164_g490 = _WindDirection;
		 float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
		 float2 break165_g490 = localDirectionalEquation164_g490;
		 float VAR_xLerp83_g490 = break165_g490.x;
		 float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
		 float3 break98_g490 = VAR_VertexPosition21_g490;
		 float3 break105_g490 = VAR_VertexPosition21_g490;
		 float VAR_zLerp95_g490 = break165_g490.y;
		 float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
		 float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
		 float3 FUNC_vertexPos123_g490 = appendResult122_g490;
		 float3 break236_g490 = FUNC_vertexPos123_g490;
		 half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
		 float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
		 float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
		 float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
		 float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
		 float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
		 float3 ase_normWorldNormal = normalize(ase_worldNormal);
		 float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
		 float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
		 float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
		 float3 break221_g490 = FUNC_vertexPos123_g490;
		 float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
		 float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
		 float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
		 float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
		 float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
		 float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
		 float3 m_None252_g490 = FUNC_vertexPos123_g490;
		 float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
		 float3 OUT_Leafs262_g490 = localIf252_g490;
		 float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
		 float3 OUT_VertexPos261 = temp_output_5_0_g490;
		 v.vertex.xyz = OUT_VertexPos261;
		 float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
		 o.screenPosition = ase_screenPos;
	 }

	 inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
	 {
		 #if !DIRECTIONAL
		 float3 lightAtten = gi.light.color;
		 #else
		 float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
		 #endif
		 half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
		 half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
		 half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
		 half4 c = half4(s.Albedo * translucency * _Translucency, 0);

		 half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
		 half4 d = half4(s.Albedo * transmission , 0);

		 SurfaceOutputStandard r;
		 r.Albedo = s.Albedo;
		 r.Normal = s.Normal;
		 r.Emission = s.Emission;
		 r.Metallic = s.Metallic;
		 r.Smoothness = s.Smoothness;
		 r.Occlusion = s.Occlusion;
		 r.Alpha = s.Alpha;
		 return LightingStandard(r, viewDir, gi) + c + d;
	 }

	 inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
	 {
		 #if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
			 gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
		 #else
			 UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
			 gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
		 #endif
	 }

	 void surf(Input i , inout SurfaceOutputStandardCustom o)
	 {
		 float Mode4_g488 = (float)_DoubleSidedNormalMode;
		 float Cull4_g488 = (float)_CullMode;
		 float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
		 float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
		 float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
		 float3 break7_g488 = bump5_g488;
		 float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
		 float3 Mirror4_g488 = appendResult11_g488;
		 float3 None4_g488 = bump5_g488;
		 float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
		 float3 OUT_Normal255 = localIf4_g488;
		 o.Normal = OUT_Normal255;
		 float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
		 float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
		 float4 VAR_AlbedoTexture267 = tex2DNode13;
		 float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
		 float4 VAR_Albedo18_g489 = VAR_Albedo101;
		 float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
		 float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
		 float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
		 float4 OUT_Albedo254 = lerpResult19_g489;
		 o.Albedo = OUT_Albedo254.rgb;
		 o.Metallic = _Metallic;
		 float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
		 float OUT_Smoothness50 = lerpResult268;
		 o.Smoothness = OUT_Smoothness50;
		 float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
		 float OUT_AO44 = lerpResult41;
		 o.Occlusion = OUT_AO44;
		 float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
		 #if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
		 float4 ase_lightColor = 0;
		 #else //aselc
		 float4 ase_lightColor = _LightColor0;
		 #endif //aselc
		 float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
		 float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
		 o.Transmission = OUT_Transmission350;
		 float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
		 o.Translucency = OUT_Translucency275;
		 clip(tex2DNode13.a - _Cutoff);
		 float temp_output_41_0_g487 = tex2DNode13.a;
		 float4 ase_screenPos = i.screenPosition;
		 float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
		 ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
		 float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
		 float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
		 dither45_g487 = step(dither45_g487, unity_LODFade.x);
		 #ifdef LOD_FADE_CROSSFADE
			 float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
		 #else
			 float staticSwitch40_g487 = temp_output_41_0_g487;
		 #endif
		 float OUT_Alpha46 = staticSwitch40_g487;
		 o.Alpha = OUT_Alpha46;
	 }



	 // vertex-to-fragment interpolation data
	 // no lightmaps:
	 #ifndef LIGHTMAP_ON
	 // half-precision fragment shader registers:
	 #ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
	 #define FOG_COMBINED_WITH_TSPACE
	 struct v2f_surf {
	   UNITY_POSITION(pos);
	   float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
	   float4 tSpace0 : TEXCOORD1;
	   float4 tSpace1 : TEXCOORD2;
	   float4 tSpace2 : TEXCOORD3;
	   fixed4 color : COLOR0;
	   float4 custompack0 : TEXCOORD4; // screenPosition
	   #if UNITY_SHOULD_SAMPLE_SH
	   half3 sh : TEXCOORD5; // SH
	   #endif
	   UNITY_LIGHTING_COORDS(6,7)
	   #if SHADER_TARGET >= 30
	   float4 lmap : TEXCOORD8;
	   #endif
	   UNITY_VERTEX_INPUT_INSTANCE_ID
	   UNITY_VERTEX_OUTPUT_STEREO
	 };
	 #endif
	 // high-precision fragment shader registers:
	 #ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
	 struct v2f_surf {
	   UNITY_POSITION(pos);
	   float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
	   float4 tSpace0 : TEXCOORD1;
	   float4 tSpace1 : TEXCOORD2;
	   float4 tSpace2 : TEXCOORD3;
	   fixed4 color : COLOR0;
	   float4 custompack0 : TEXCOORD4; // screenPosition
	   #if UNITY_SHOULD_SAMPLE_SH
	   half3 sh : TEXCOORD5; // SH
	   #endif
	   UNITY_FOG_COORDS(6)
	   UNITY_SHADOW_COORDS(7)
	   #if SHADER_TARGET >= 30
	   float4 lmap : TEXCOORD8;
	   #endif
	   UNITY_VERTEX_INPUT_INSTANCE_ID
	   UNITY_VERTEX_OUTPUT_STEREO
	 };
	 #endif
	 #endif
	 // with lightmaps:
	 #ifdef LIGHTMAP_ON
	 // half-precision fragment shader registers:
	 #ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
	 #define FOG_COMBINED_WITH_TSPACE
	 struct v2f_surf {
	   UNITY_POSITION(pos);
	   float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
	   float4 tSpace0 : TEXCOORD1;
	   float4 tSpace1 : TEXCOORD2;
	   float4 tSpace2 : TEXCOORD3;
	   fixed4 color : COLOR0;
	   float4 custompack0 : TEXCOORD4; // screenPosition
	   float4 lmap : TEXCOORD5;
	   UNITY_LIGHTING_COORDS(6,7)
	   UNITY_VERTEX_INPUT_INSTANCE_ID
	   UNITY_VERTEX_OUTPUT_STEREO
	 };
	 #endif
	 // high-precision fragment shader registers:
	 #ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
	 struct v2f_surf {
	   UNITY_POSITION(pos);
	   float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
	   float4 tSpace0 : TEXCOORD1;
	   float4 tSpace1 : TEXCOORD2;
	   float4 tSpace2 : TEXCOORD3;
	   fixed4 color : COLOR0;
	   float4 custompack0 : TEXCOORD4; // screenPosition
	   float4 lmap : TEXCOORD5;
	   UNITY_FOG_COORDS(6)
	   UNITY_SHADOW_COORDS(7)
	   UNITY_VERTEX_INPUT_INSTANCE_ID
	   UNITY_VERTEX_OUTPUT_STEREO
	 };
	 #endif
	 #endif
	 float4 _texcoord_ST;
	 float4 _texcoord4_ST;

	 // vertex shader
	 v2f_surf vert_surf(appdata_full v) {
	   UNITY_SETUP_INSTANCE_ID(v);
	   v2f_surf o;
	   UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
	   UNITY_TRANSFER_INSTANCE_ID(v,o);
	   UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
	   Input customInputData;
	   vertexDataFunc(v, customInputData);
	   o.custompack0.xyzw = customInputData.screenPosition;
	   o.pos = UnityObjectToClipPos(v.vertex);
	   o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
	   o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
	   float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
	   float3 worldNormal = UnityObjectToWorldNormal(v.normal);
	   fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
	   fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
	   fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
	   o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
	   o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
	   o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
	   o.color = v.color;
	   #ifdef DYNAMICLIGHTMAP_ON
	   o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
	   #endif
	   #ifdef LIGHTMAP_ON
	   o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	   #endif

	   // SH/ambient and vertex lights
	   #ifndef LIGHTMAP_ON
		 #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
		   o.sh = 0;
		   // Approximated illumination from non-important point lights
		   #ifdef VERTEXLIGHT_ON
			 o.sh += Shade4PointLights(
			   unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
			   unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
			   unity_4LightAtten0, worldPos, worldNormal);
		   #endif
		   o.sh = ShadeSHPerVertex(worldNormal, o.sh);
		 #endif
	   #endif // !LIGHTMAP_ON

	   UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
	   #ifdef FOG_COMBINED_WITH_TSPACE
		 UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
	   #elif defined (FOG_COMBINED_WITH_WORLD_POS)
		 UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
	   #else
		 UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
	   #endif
	   return o;
	 }

	 // fragment shader
	 fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
	   UNITY_SETUP_INSTANCE_ID(IN);
	 // prepare and unpack data
	 Input surfIN;
	 #ifdef FOG_COMBINED_WITH_TSPACE
	   UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
	 #elif defined (FOG_COMBINED_WITH_WORLD_POS)
	   UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
	 #else
	   UNITY_EXTRACT_FOG(IN);
	 #endif
	 #ifdef FOG_COMBINED_WITH_TSPACE
	   UNITY_RECONSTRUCT_TBN(IN);
	 #else
	   UNITY_EXTRACT_TBN(IN);
	 #endif
	 UNITY_INITIALIZE_OUTPUT(Input,surfIN);
	 surfIN.uv_texcoord.x = 1.0;
	 surfIN.ASEVFace.x = 1.0;
	 surfIN.vertexColor.x = 1.0;
	 surfIN.uv4_texcoord4.x = 1.0;
	 surfIN.screenPosition.x = 1.0;
	 surfIN.uv_texcoord = IN.pack0.xy;
	 surfIN.uv4_texcoord4 = IN.pack0.zw;
	 surfIN.screenPosition = IN.custompack0.xyzw;
	 float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
	 #ifndef USING_DIRECTIONAL_LIGHT
	   fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
	 #else
	   fixed3 lightDir = _WorldSpaceLightPos0.xyz;
	 #endif
	 float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
	 surfIN.vertexColor = IN.color;
	 #if UNITY_VFACE_FLIPPED
		vface = -vface;
	 #endif
	 surfIN.ASEVFace = vface;
	 #ifdef UNITY_COMPILER_HLSL
	 SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
	 #else
	 SurfaceOutputStandardCustom o;
	 #endif
	 o.Albedo = 0.0;
	 o.Emission = 0.0;
	 o.Alpha = 0.0;
	 o.Occlusion = 1.0;
	 fixed3 normalWorldVertex = fixed3(0,0,1);
	 o.Normal = fixed3(0,0,1);

	 // call surface function
	 surf(surfIN, o);

	 // compute lighting & shadowing factor
	 UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
	 fixed4 c = 0;
	 float3 worldN;
	 worldN.x = dot(_unity_tbn_0, o.Normal);
	 worldN.y = dot(_unity_tbn_1, o.Normal);
	 worldN.z = dot(_unity_tbn_2, o.Normal);
	 worldN = normalize(worldN);
	 o.Normal = worldN;

	 // Setup lighting environment
	 UnityGI gi;
	 UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
	 gi.indirect.diffuse = 0;
	 gi.indirect.specular = 0;
	 gi.light.color = _LightColor0.rgb;
	 gi.light.dir = lightDir;
	 // Call GI (lightmaps/SH/reflections) lighting function
	 UnityGIInput giInput;
	 UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
	 giInput.light = gi.light;
	 giInput.worldPos = worldPos;
	 giInput.worldViewDir = worldViewDir;
	 giInput.atten = atten;
	 #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
	   giInput.lightmapUV = IN.lmap;
	 #else
	   giInput.lightmapUV = 0.0;
	 #endif
	 #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
	   giInput.ambient = IN.sh;
	 #else
	   giInput.ambient.rgb = 0.0;
	 #endif
	 giInput.probeHDR[0] = unity_SpecCube0_HDR;
	 giInput.probeHDR[1] = unity_SpecCube1_HDR;
	 #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
	   giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
	 #endif
	 #ifdef UNITY_SPECCUBE_BOX_PROJECTION
	   giInput.boxMax[0] = unity_SpecCube0_BoxMax;
	   giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
	   giInput.boxMax[1] = unity_SpecCube1_BoxMax;
	   giInput.boxMin[1] = unity_SpecCube1_BoxMin;
	   giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
	 #endif
	 LightingStandardCustom_GI(o, giInput, gi);

	 // realtime lighting: call lighting function
	 c += LightingStandardCustom(o, worldViewDir, gi);
	 UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
	 return c;
   }


   #endif

		 // -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON 
		 #if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && !defined(_GLOSSYREFLECTIONS_OFF) && !defined(_SPECULARHIGHLIGHTS_OFF)
		 // Surface shader code generated based on:
		 // vertex modifier: 'vertexDataFunc'
		 // writes to per-pixel normal: YES
		 // writes to emission: no
		 // writes to occlusion: YES
		 // needs world space reflection vector: no
		 // needs world space normal vector: no
		 // needs screen space position: no
		 // needs world space position: no
		 // needs view direction: no
		 // needs world space view direction: no
		 // needs world space position for lighting: YES
		 // needs world space view direction for lighting: YES
		 // needs world space view direction for lightmaps: no
		 // needs vertex color: YES
		 // needs VFACE: YES
		 // passes tangent-to-world matrix to pixel shader: YES
		 // reads from normal: no
		 // 2 texcoords actually used
		 //   float2 _texcoord
		 //   float2 _texcoord4
		 #include "UnityCG.cginc"
		 #include "Lighting.cginc"
		 #include "AutoLight.cginc"

		 #define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
		 #define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
		 #define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

		 // Original surface shader snippet:
		 #line 48 ""
		 #ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
		 #endif
		 /* UNITY: Original start of shader */
				 #include "UnityShaderVariables.cginc"
				 #include "UnityStandardUtils.cginc"
				 #include "UnityPBSLighting.cginc"
				 //#pragma target 3.0
				 //#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
				 //#pragma shader_feature _GLOSSYREFLECTIONS_OFF
				 //#pragma multi_compile __ LOD_FADE_CROSSFADE
				 //#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
				 struct Input
				 {
					 float2 uv_texcoord;
					 half ASEVFace : VFACE;
					 float4 vertexColor : COLOR;
					 float2 uv4_texcoord4;
					 float4 screenPosition;
				 };

				 struct SurfaceOutputStandardCustom
				 {
					 half3 Albedo;
					 half3 Normal;
					 half3 Emission;
					 half Metallic;
					 half Smoothness;
					 half Occlusion;
					 half Alpha;
					 half3 Transmission;
					 half3 Translucency;
				 };

				 uniform int _WindModeLeaves;
				 uniform float _WindStrength;
				 uniform float _GlobalWindInfluence;
				 uniform float _RandomWindOffset;
				 uniform float _WindPulse;
				 uniform float _WindDirection;
				 uniform float _WindTurbulence;
				 uniform float _GlobalTurbulenceInfluence;
				 uniform int _DoubleSidedNormalMode;
				 uniform int _CullMode;
				 uniform sampler2D _BumpMap;
				 uniform float4 _BumpMap_ST;
				 uniform half _BumpScale;
				 uniform float _ColorVariation;
				 uniform half _Hue;
				 uniform float4 _Color;
				 uniform sampler2D _MainTex;
				 uniform float4 _MainTex_ST;
				 uniform float _Saturation;
				 uniform float _Value;
				 uniform int _ColorShifting;
				 uniform float _Metallic;
				 uniform float _Glossiness;
				 uniform half _OcclusionStrength;
				 uniform float4 _TransmissionTint;
				 uniform half _Translucency;
				 uniform half _TransNormalDistortion;
				 uniform half _TransScattering;
				 uniform half _TransDirect;
				 uniform half _TransAmbient;
				 uniform half _TransShadow;
				 uniform float4 _TranslucencyTint;
				 uniform half _Cutoff;


				 float2 DirectionalEquation(float _WindDirection)
				 {
					 float d = _WindDirection * 0.0174532924;
					 float xL = cos(d) + 1 / 2;
					 float zL = sin(d) + 1 / 2;
					 return float2(zL,xL);
				 }


				 float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
				 {
					 float3 Output = m_None;
					 if (m_Switch == 0) { Output = m_Leaves; }
					 if (m_Switch == 1) { Output = m_Palm; }
					 if (m_Switch == 2) { Output = m_Grass; }
					 if (m_Switch == 3) { Output = m_None; }
					 return Output;
				 }


				 float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
				 {
					 float3 OUT = None;
					 if (Cull == 0) {
						 if (Mode == 0)
							 OUT = Flip;
						 if (Mode == 1)
							 OUT = Mirror;
						 if (Mode == 2)
							 OUT == None;
					 }
		 else {
			OUT = None;
		}
		return OUT;
	}


	float3 HSVToRGB(float3 c)
	{
		float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
		float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
		return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
	}


	float3 RGBToHSV(float3 c)
	{
		float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
		float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
		float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
		float d = q.x - min(q.w, q.y);
		float e = 1.0e-10;
		return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
	}

	inline float Dither8x8Bayer(int x, int y)
	{
		const float dither[64] = {
			 1, 49, 13, 61,  4, 52, 16, 64,
			33, 17, 45, 29, 36, 20, 48, 32,
			 9, 57,  5, 53, 12, 60,  8, 56,
			41, 25, 37, 21, 44, 28, 40, 24,
			 3, 51, 15, 63,  2, 50, 14, 62,
			35, 19, 47, 31, 34, 18, 46, 30,
			11, 59,  7, 55, 10, 58,  6, 54,
			43, 27, 39, 23, 42, 26, 38, 22};
		int r = y * 8 + x;
		return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
	}


	void vertexDataFunc(inout appdata_full v, out Input o)
	{
		UNITY_INITIALIZE_OUTPUT(Input, o);
		int m_Switch252_g490 = _WindModeLeaves;
		float3 ase_vertex3Pos = v.vertex.xyz;
		float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
		float3 break109_g490 = VAR_VertexPosition21_g490;
		float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
		float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
		float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
		float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
		float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
		float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
		float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
		float VAR_WindPulse274_g490 = _WindPulse;
		float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
		float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
		float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
		float _WindDirection164_g490 = _WindDirection;
		float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
		float2 break165_g490 = localDirectionalEquation164_g490;
		float VAR_xLerp83_g490 = break165_g490.x;
		float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
		float3 break98_g490 = VAR_VertexPosition21_g490;
		float3 break105_g490 = VAR_VertexPosition21_g490;
		float VAR_zLerp95_g490 = break165_g490.y;
		float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
		float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
		float3 FUNC_vertexPos123_g490 = appendResult122_g490;
		float3 break236_g490 = FUNC_vertexPos123_g490;
		half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
		float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
		float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
		float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
		float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
		float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
		float3 ase_normWorldNormal = normalize(ase_worldNormal);
		float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
		float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
		float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
		float3 break221_g490 = FUNC_vertexPos123_g490;
		float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
		float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
		float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
		float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
		float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
		float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
		float3 m_None252_g490 = FUNC_vertexPos123_g490;
		float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
		float3 OUT_Leafs262_g490 = localIf252_g490;
		float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
		float3 OUT_VertexPos261 = temp_output_5_0_g490;
		v.vertex.xyz = OUT_VertexPos261;
		float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
		o.screenPosition = ase_screenPos;
	}

	inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
	{
		#if !DIRECTIONAL
		float3 lightAtten = gi.light.color;
		#else
		float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
		#endif
		half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
		half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
		half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
		half4 c = half4(s.Albedo * translucency * _Translucency, 0);

		half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
		half4 d = half4(s.Albedo * transmission , 0);

		SurfaceOutputStandard r;
		r.Albedo = s.Albedo;
		r.Normal = s.Normal;
		r.Emission = s.Emission;
		r.Metallic = s.Metallic;
		r.Smoothness = s.Smoothness;
		r.Occlusion = s.Occlusion;
		r.Alpha = s.Alpha;
		return LightingStandard(r, viewDir, gi) + c + d;
	}

	inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
	{
		#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
			gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
		#else
			UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
			gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
		#endif
	}

	void surf(Input i , inout SurfaceOutputStandardCustom o)
	{
		float Mode4_g488 = (float)_DoubleSidedNormalMode;
		float Cull4_g488 = (float)_CullMode;
		float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
		float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
		float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
		float3 break7_g488 = bump5_g488;
		float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
		float3 Mirror4_g488 = appendResult11_g488;
		float3 None4_g488 = bump5_g488;
		float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
		float3 OUT_Normal255 = localIf4_g488;
		o.Normal = OUT_Normal255;
		float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
		float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
		float4 VAR_AlbedoTexture267 = tex2DNode13;
		float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
		float4 VAR_Albedo18_g489 = VAR_Albedo101;
		float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
		float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
		float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
		float4 OUT_Albedo254 = lerpResult19_g489;
		o.Albedo = OUT_Albedo254.rgb;
		o.Metallic = _Metallic;
		float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
		float OUT_Smoothness50 = lerpResult268;
		o.Smoothness = OUT_Smoothness50;
		float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
		float OUT_AO44 = lerpResult41;
		o.Occlusion = OUT_AO44;
		float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
		#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
		float4 ase_lightColor = 0;
		#else //aselc
		float4 ase_lightColor = _LightColor0;
		#endif //aselc
		float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
		float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
		o.Transmission = OUT_Transmission350;
		float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
		o.Translucency = OUT_Translucency275;
		clip(tex2DNode13.a - _Cutoff);
		float temp_output_41_0_g487 = tex2DNode13.a;
		float4 ase_screenPos = i.screenPosition;
		float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
		ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
		float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
		float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
		dither45_g487 = step(dither45_g487, unity_LODFade.x);
		#ifdef LOD_FADE_CROSSFADE
			float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
		#else
			float staticSwitch40_g487 = temp_output_41_0_g487;
		#endif
		float OUT_Alpha46 = staticSwitch40_g487;
		o.Alpha = OUT_Alpha46;
	}



	// vertex-to-fragment interpolation data
	// no lightmaps:
	#ifndef LIGHTMAP_ON
	// half-precision fragment shader registers:
	#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
	#define FOG_COMBINED_WITH_TSPACE
	struct v2f_surf {
	  UNITY_POSITION(pos);
	  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
	  float4 tSpace0 : TEXCOORD1;
	  float4 tSpace1 : TEXCOORD2;
	  float4 tSpace2 : TEXCOORD3;
	  fixed4 color : COLOR0;
	  float4 custompack0 : TEXCOORD4; // screenPosition
	  #if UNITY_SHOULD_SAMPLE_SH
	  half3 sh : TEXCOORD5; // SH
	  #endif
	  UNITY_LIGHTING_COORDS(6,7)
	  #if SHADER_TARGET >= 30
	  float4 lmap : TEXCOORD8;
	  #endif
	  UNITY_VERTEX_INPUT_INSTANCE_ID
	  UNITY_VERTEX_OUTPUT_STEREO
	};
	#endif
	// high-precision fragment shader registers:
	#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
	struct v2f_surf {
	  UNITY_POSITION(pos);
	  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
	  float4 tSpace0 : TEXCOORD1;
	  float4 tSpace1 : TEXCOORD2;
	  float4 tSpace2 : TEXCOORD3;
	  fixed4 color : COLOR0;
	  float4 custompack0 : TEXCOORD4; // screenPosition
	  #if UNITY_SHOULD_SAMPLE_SH
	  half3 sh : TEXCOORD5; // SH
	  #endif
	  UNITY_FOG_COORDS(6)
	  UNITY_SHADOW_COORDS(7)
	  #if SHADER_TARGET >= 30
	  float4 lmap : TEXCOORD8;
	  #endif
	  UNITY_VERTEX_INPUT_INSTANCE_ID
	  UNITY_VERTEX_OUTPUT_STEREO
	};
	#endif
	#endif
	// with lightmaps:
	#ifdef LIGHTMAP_ON
	// half-precision fragment shader registers:
	#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
	#define FOG_COMBINED_WITH_TSPACE
	struct v2f_surf {
	  UNITY_POSITION(pos);
	  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
	  float4 tSpace0 : TEXCOORD1;
	  float4 tSpace1 : TEXCOORD2;
	  float4 tSpace2 : TEXCOORD3;
	  fixed4 color : COLOR0;
	  float4 custompack0 : TEXCOORD4; // screenPosition
	  float4 lmap : TEXCOORD5;
	  UNITY_LIGHTING_COORDS(6,7)
	  UNITY_VERTEX_INPUT_INSTANCE_ID
	  UNITY_VERTEX_OUTPUT_STEREO
	};
	#endif
	// high-precision fragment shader registers:
	#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
	struct v2f_surf {
	  UNITY_POSITION(pos);
	  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
	  float4 tSpace0 : TEXCOORD1;
	  float4 tSpace1 : TEXCOORD2;
	  float4 tSpace2 : TEXCOORD3;
	  fixed4 color : COLOR0;
	  float4 custompack0 : TEXCOORD4; // screenPosition
	  float4 lmap : TEXCOORD5;
	  UNITY_FOG_COORDS(6)
	  UNITY_SHADOW_COORDS(7)
	  UNITY_VERTEX_INPUT_INSTANCE_ID
	  UNITY_VERTEX_OUTPUT_STEREO
	};
	#endif
	#endif
	float4 _texcoord_ST;
	float4 _texcoord4_ST;

	// vertex shader
	v2f_surf vert_surf(appdata_full v) {
	  UNITY_SETUP_INSTANCE_ID(v);
	  v2f_surf o;
	  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
	  UNITY_TRANSFER_INSTANCE_ID(v,o);
	  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
	  Input customInputData;
	  vertexDataFunc(v, customInputData);
	  o.custompack0.xyzw = customInputData.screenPosition;
	  o.pos = UnityObjectToClipPos(v.vertex);
	  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
	  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
	  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
	  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
	  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
	  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
	  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
	  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
	  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
	  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
	  o.color = v.color;
	  #ifdef DYNAMICLIGHTMAP_ON
	  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
	  #endif
	  #ifdef LIGHTMAP_ON
	  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	  #endif

	  // SH/ambient and vertex lights
	  #ifndef LIGHTMAP_ON
		#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
		  o.sh = 0;
		  // Approximated illumination from non-important point lights
		  #ifdef VERTEXLIGHT_ON
			o.sh += Shade4PointLights(
			  unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
			  unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
			  unity_4LightAtten0, worldPos, worldNormal);
		  #endif
		  o.sh = ShadeSHPerVertex(worldNormal, o.sh);
		#endif
	  #endif // !LIGHTMAP_ON

	  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
	  #ifdef FOG_COMBINED_WITH_TSPACE
		UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
	  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
		UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
	  #else
		UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
	  #endif
	  return o;
	}

	// fragment shader
	fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
	  UNITY_SETUP_INSTANCE_ID(IN);
	// prepare and unpack data
	Input surfIN;
	#ifdef FOG_COMBINED_WITH_TSPACE
	  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
	#elif defined (FOG_COMBINED_WITH_WORLD_POS)
	  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
	#else
	  UNITY_EXTRACT_FOG(IN);
	#endif
	#ifdef FOG_COMBINED_WITH_TSPACE
	  UNITY_RECONSTRUCT_TBN(IN);
	#else
	  UNITY_EXTRACT_TBN(IN);
	#endif
	UNITY_INITIALIZE_OUTPUT(Input,surfIN);
	surfIN.uv_texcoord.x = 1.0;
	surfIN.ASEVFace.x = 1.0;
	surfIN.vertexColor.x = 1.0;
	surfIN.uv4_texcoord4.x = 1.0;
	surfIN.screenPosition.x = 1.0;
	surfIN.uv_texcoord = IN.pack0.xy;
	surfIN.uv4_texcoord4 = IN.pack0.zw;
	surfIN.screenPosition = IN.custompack0.xyzw;
	float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
	#ifndef USING_DIRECTIONAL_LIGHT
	  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
	#else
	  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
	#endif
	float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
	surfIN.vertexColor = IN.color;
	#if UNITY_VFACE_FLIPPED
	   vface = -vface;
	#endif
	surfIN.ASEVFace = vface;
	#ifdef UNITY_COMPILER_HLSL
	SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
	#else
	SurfaceOutputStandardCustom o;
	#endif
	o.Albedo = 0.0;
	o.Emission = 0.0;
	o.Alpha = 0.0;
	o.Occlusion = 1.0;
	fixed3 normalWorldVertex = fixed3(0,0,1);
	o.Normal = fixed3(0,0,1);

	// call surface function
	surf(surfIN, o);

	// compute lighting & shadowing factor
	UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
	fixed4 c = 0;
	float3 worldN;
	worldN.x = dot(_unity_tbn_0, o.Normal);
	worldN.y = dot(_unity_tbn_1, o.Normal);
	worldN.z = dot(_unity_tbn_2, o.Normal);
	worldN = normalize(worldN);
	o.Normal = worldN;

	// Setup lighting environment
	UnityGI gi;
	UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
	gi.indirect.diffuse = 0;
	gi.indirect.specular = 0;
	gi.light.color = _LightColor0.rgb;
	gi.light.dir = lightDir;
	// Call GI (lightmaps/SH/reflections) lighting function
	UnityGIInput giInput;
	UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
	giInput.light = gi.light;
	giInput.worldPos = worldPos;
	giInput.worldViewDir = worldViewDir;
	giInput.atten = atten;
	#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
	  giInput.lightmapUV = IN.lmap;
	#else
	  giInput.lightmapUV = 0.0;
	#endif
	#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
	  giInput.ambient = IN.sh;
	#else
	  giInput.ambient.rgb = 0.0;
	#endif
	giInput.probeHDR[0] = unity_SpecCube0_HDR;
	giInput.probeHDR[1] = unity_SpecCube1_HDR;
	#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
	  giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
	#endif
	#ifdef UNITY_SPECCUBE_BOX_PROJECTION
	  giInput.boxMax[0] = unity_SpecCube0_BoxMax;
	  giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
	  giInput.boxMax[1] = unity_SpecCube1_BoxMax;
	  giInput.boxMin[1] = unity_SpecCube1_BoxMin;
	  giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
	#endif
	LightingStandardCustom_GI(o, giInput, gi);

	// realtime lighting: call lighting function
	c += LightingStandardCustom(o, worldViewDir, gi);
	UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
	return c;
  }


  #endif

		// -------- variant for: _GLOSSYREFLECTIONS_OFF 
		#if defined(_GLOSSYREFLECTIONS_OFF) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_SPECULARHIGHLIGHTS_OFF)
		// Surface shader code generated based on:
		// vertex modifier: 'vertexDataFunc'
		// writes to per-pixel normal: YES
		// writes to emission: no
		// writes to occlusion: YES
		// needs world space reflection vector: no
		// needs world space normal vector: no
		// needs screen space position: no
		// needs world space position: no
		// needs view direction: no
		// needs world space view direction: no
		// needs world space position for lighting: YES
		// needs world space view direction for lighting: YES
		// needs world space view direction for lightmaps: no
		// needs vertex color: YES
		// needs VFACE: YES
		// passes tangent-to-world matrix to pixel shader: YES
		// reads from normal: no
		// 2 texcoords actually used
		//   float2 _texcoord
		//   float2 _texcoord4
		#include "UnityCG.cginc"
		#include "Lighting.cginc"
		#include "AutoLight.cginc"

		#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
		#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
		#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

		// Original surface shader snippet:
		#line 48 ""
		#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
		#endif
		/* UNITY: Original start of shader */
				#include "UnityShaderVariables.cginc"
				#include "UnityStandardUtils.cginc"
				#include "UnityPBSLighting.cginc"
				//#pragma target 3.0
				//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
				//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
				//#pragma multi_compile __ LOD_FADE_CROSSFADE
				//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
				struct Input
				{
					float2 uv_texcoord;
					half ASEVFace : VFACE;
					float4 vertexColor : COLOR;
					float2 uv4_texcoord4;
					float4 screenPosition;
				};

				struct SurfaceOutputStandardCustom
				{
					half3 Albedo;
					half3 Normal;
					half3 Emission;
					half Metallic;
					half Smoothness;
					half Occlusion;
					half Alpha;
					half3 Transmission;
					half3 Translucency;
				};

				uniform int _WindModeLeaves;
				uniform float _WindStrength;
				uniform float _GlobalWindInfluence;
				uniform float _RandomWindOffset;
				uniform float _WindPulse;
				uniform float _WindDirection;
				uniform float _WindTurbulence;
				uniform float _GlobalTurbulenceInfluence;
				uniform int _DoubleSidedNormalMode;
				uniform int _CullMode;
				uniform sampler2D _BumpMap;
				uniform float4 _BumpMap_ST;
				uniform half _BumpScale;
				uniform float _ColorVariation;
				uniform half _Hue;
				uniform float4 _Color;
				uniform sampler2D _MainTex;
				uniform float4 _MainTex_ST;
				uniform float _Saturation;
				uniform float _Value;
				uniform int _ColorShifting;
				uniform float _Metallic;
				uniform float _Glossiness;
				uniform half _OcclusionStrength;
				uniform float4 _TransmissionTint;
				uniform half _Translucency;
				uniform half _TransNormalDistortion;
				uniform half _TransScattering;
				uniform half _TransDirect;
				uniform half _TransAmbient;
				uniform half _TransShadow;
				uniform float4 _TranslucencyTint;
				uniform half _Cutoff;


				float2 DirectionalEquation(float _WindDirection)
				{
					float d = _WindDirection * 0.0174532924;
					float xL = cos(d) + 1 / 2;
					float zL = sin(d) + 1 / 2;
					return float2(zL,xL);
				}


				float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
				{
					float3 Output = m_None;
					if (m_Switch == 0) { Output = m_Leaves; }
					if (m_Switch == 1) { Output = m_Palm; }
					if (m_Switch == 2) { Output = m_Grass; }
					if (m_Switch == 3) { Output = m_None; }
					return Output;
				}


				float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
				{
					float3 OUT = None;
					if (Cull == 0) {
						if (Mode == 0)
							OUT = Flip;
						if (Mode == 1)
							OUT = Mirror;
						if (Mode == 2)
							OUT == None;
					}
		else {
		   OUT = None;
	   }
	   return OUT;
   }


   float3 HSVToRGB(float3 c)
   {
	   float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	   float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	   return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
   }


   float3 RGBToHSV(float3 c)
   {
	   float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	   float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	   float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	   float d = q.x - min(q.w, q.y);
	   float e = 1.0e-10;
	   return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
   }

   inline float Dither8x8Bayer(int x, int y)
   {
	   const float dither[64] = {
			1, 49, 13, 61,  4, 52, 16, 64,
		   33, 17, 45, 29, 36, 20, 48, 32,
			9, 57,  5, 53, 12, 60,  8, 56,
		   41, 25, 37, 21, 44, 28, 40, 24,
			3, 51, 15, 63,  2, 50, 14, 62,
		   35, 19, 47, 31, 34, 18, 46, 30,
		   11, 59,  7, 55, 10, 58,  6, 54,
		   43, 27, 39, 23, 42, 26, 38, 22};
	   int r = y * 8 + x;
	   return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
   }


   void vertexDataFunc(inout appdata_full v, out Input o)
   {
	   UNITY_INITIALIZE_OUTPUT(Input, o);
	   int m_Switch252_g490 = _WindModeLeaves;
	   float3 ase_vertex3Pos = v.vertex.xyz;
	   float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	   float3 break109_g490 = VAR_VertexPosition21_g490;
	   float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	   float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	   float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	   float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	   float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	   float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	   float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	   float VAR_WindPulse274_g490 = _WindPulse;
	   float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	   float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	   float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	   float _WindDirection164_g490 = _WindDirection;
	   float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	   float2 break165_g490 = localDirectionalEquation164_g490;
	   float VAR_xLerp83_g490 = break165_g490.x;
	   float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	   float3 break98_g490 = VAR_VertexPosition21_g490;
	   float3 break105_g490 = VAR_VertexPosition21_g490;
	   float VAR_zLerp95_g490 = break165_g490.y;
	   float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	   float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	   float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	   float3 break236_g490 = FUNC_vertexPos123_g490;
	   half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	   float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	   float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	   float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	   float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	   float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	   float3 ase_normWorldNormal = normalize(ase_worldNormal);
	   float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	   float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	   float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	   float3 break221_g490 = FUNC_vertexPos123_g490;
	   float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	   float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	   float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	   float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	   float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	   float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	   float3 m_None252_g490 = FUNC_vertexPos123_g490;
	   float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	   float3 OUT_Leafs262_g490 = localIf252_g490;
	   float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	   float3 OUT_VertexPos261 = temp_output_5_0_g490;
	   v.vertex.xyz = OUT_VertexPos261;
	   float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	   o.screenPosition = ase_screenPos;
   }

   inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
   {
	   #if !DIRECTIONAL
	   float3 lightAtten = gi.light.color;
	   #else
	   float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	   #endif
	   half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	   half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	   half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	   half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	   half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	   half4 d = half4(s.Albedo * transmission , 0);

	   SurfaceOutputStandard r;
	   r.Albedo = s.Albedo;
	   r.Normal = s.Normal;
	   r.Emission = s.Emission;
	   r.Metallic = s.Metallic;
	   r.Smoothness = s.Smoothness;
	   r.Occlusion = s.Occlusion;
	   r.Alpha = s.Alpha;
	   return LightingStandard(r, viewDir, gi) + c + d;
   }

   inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
   {
	   #if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		   gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	   #else
		   UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		   gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	   #endif
   }

   void surf(Input i , inout SurfaceOutputStandardCustom o)
   {
	   float Mode4_g488 = (float)_DoubleSidedNormalMode;
	   float Cull4_g488 = (float)_CullMode;
	   float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	   float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	   float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	   float3 break7_g488 = bump5_g488;
	   float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	   float3 Mirror4_g488 = appendResult11_g488;
	   float3 None4_g488 = bump5_g488;
	   float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	   float3 OUT_Normal255 = localIf4_g488;
	   o.Normal = OUT_Normal255;
	   float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	   float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	   float4 VAR_AlbedoTexture267 = tex2DNode13;
	   float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	   float4 VAR_Albedo18_g489 = VAR_Albedo101;
	   float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	   float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	   float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	   float4 OUT_Albedo254 = lerpResult19_g489;
	   o.Albedo = OUT_Albedo254.rgb;
	   o.Metallic = _Metallic;
	   float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	   float OUT_Smoothness50 = lerpResult268;
	   o.Smoothness = OUT_Smoothness50;
	   float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	   float OUT_AO44 = lerpResult41;
	   o.Occlusion = OUT_AO44;
	   float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	   #if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	   float4 ase_lightColor = 0;
	   #else //aselc
	   float4 ase_lightColor = _LightColor0;
	   #endif //aselc
	   float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	   float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	   o.Transmission = OUT_Transmission350;
	   float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	   o.Translucency = OUT_Translucency275;
	   clip(tex2DNode13.a - _Cutoff);
	   float temp_output_41_0_g487 = tex2DNode13.a;
	   float4 ase_screenPos = i.screenPosition;
	   float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	   ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	   float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	   float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	   dither45_g487 = step(dither45_g487, unity_LODFade.x);
	   #ifdef LOD_FADE_CROSSFADE
		   float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	   #else
		   float staticSwitch40_g487 = temp_output_41_0_g487;
	   #endif
	   float OUT_Alpha46 = staticSwitch40_g487;
	   o.Alpha = OUT_Alpha46;
   }



   // vertex-to-fragment interpolation data
   // no lightmaps:
   #ifndef LIGHTMAP_ON
   // half-precision fragment shader registers:
   #ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
   #define FOG_COMBINED_WITH_TSPACE
   struct v2f_surf {
	 UNITY_POSITION(pos);
	 float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
	 float4 tSpace0 : TEXCOORD1;
	 float4 tSpace1 : TEXCOORD2;
	 float4 tSpace2 : TEXCOORD3;
	 fixed4 color : COLOR0;
	 float4 custompack0 : TEXCOORD4; // screenPosition
	 #if UNITY_SHOULD_SAMPLE_SH
	 half3 sh : TEXCOORD5; // SH
	 #endif
	 UNITY_LIGHTING_COORDS(6,7)
	 #if SHADER_TARGET >= 30
	 float4 lmap : TEXCOORD8;
	 #endif
	 UNITY_VERTEX_INPUT_INSTANCE_ID
	 UNITY_VERTEX_OUTPUT_STEREO
   };
   #endif
   // high-precision fragment shader registers:
   #ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
   struct v2f_surf {
	 UNITY_POSITION(pos);
	 float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
	 float4 tSpace0 : TEXCOORD1;
	 float4 tSpace1 : TEXCOORD2;
	 float4 tSpace2 : TEXCOORD3;
	 fixed4 color : COLOR0;
	 float4 custompack0 : TEXCOORD4; // screenPosition
	 #if UNITY_SHOULD_SAMPLE_SH
	 half3 sh : TEXCOORD5; // SH
	 #endif
	 UNITY_FOG_COORDS(6)
	 UNITY_SHADOW_COORDS(7)
	 #if SHADER_TARGET >= 30
	 float4 lmap : TEXCOORD8;
	 #endif
	 UNITY_VERTEX_INPUT_INSTANCE_ID
	 UNITY_VERTEX_OUTPUT_STEREO
   };
   #endif
   #endif
   // with lightmaps:
   #ifdef LIGHTMAP_ON
   // half-precision fragment shader registers:
   #ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
   #define FOG_COMBINED_WITH_TSPACE
   struct v2f_surf {
	 UNITY_POSITION(pos);
	 float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
	 float4 tSpace0 : TEXCOORD1;
	 float4 tSpace1 : TEXCOORD2;
	 float4 tSpace2 : TEXCOORD3;
	 fixed4 color : COLOR0;
	 float4 custompack0 : TEXCOORD4; // screenPosition
	 float4 lmap : TEXCOORD5;
	 UNITY_LIGHTING_COORDS(6,7)
	 UNITY_VERTEX_INPUT_INSTANCE_ID
	 UNITY_VERTEX_OUTPUT_STEREO
   };
   #endif
   // high-precision fragment shader registers:
   #ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
   struct v2f_surf {
	 UNITY_POSITION(pos);
	 float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
	 float4 tSpace0 : TEXCOORD1;
	 float4 tSpace1 : TEXCOORD2;
	 float4 tSpace2 : TEXCOORD3;
	 fixed4 color : COLOR0;
	 float4 custompack0 : TEXCOORD4; // screenPosition
	 float4 lmap : TEXCOORD5;
	 UNITY_FOG_COORDS(6)
	 UNITY_SHADOW_COORDS(7)
	 UNITY_VERTEX_INPUT_INSTANCE_ID
	 UNITY_VERTEX_OUTPUT_STEREO
   };
   #endif
   #endif
   float4 _texcoord_ST;
   float4 _texcoord4_ST;

   // vertex shader
   v2f_surf vert_surf(appdata_full v) {
	 UNITY_SETUP_INSTANCE_ID(v);
	 v2f_surf o;
	 UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
	 UNITY_TRANSFER_INSTANCE_ID(v,o);
	 UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
	 Input customInputData;
	 vertexDataFunc(v, customInputData);
	 o.custompack0.xyzw = customInputData.screenPosition;
	 o.pos = UnityObjectToClipPos(v.vertex);
	 o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
	 o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
	 float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
	 float3 worldNormal = UnityObjectToWorldNormal(v.normal);
	 fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
	 fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
	 fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
	 o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
	 o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
	 o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
	 o.color = v.color;
	 #ifdef DYNAMICLIGHTMAP_ON
	 o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
	 #endif
	 #ifdef LIGHTMAP_ON
	 o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	 #endif

	 // SH/ambient and vertex lights
	 #ifndef LIGHTMAP_ON
	   #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
		 o.sh = 0;
		 // Approximated illumination from non-important point lights
		 #ifdef VERTEXLIGHT_ON
		   o.sh += Shade4PointLights(
			 unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
			 unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
			 unity_4LightAtten0, worldPos, worldNormal);
		 #endif
		 o.sh = ShadeSHPerVertex(worldNormal, o.sh);
	   #endif
	 #endif // !LIGHTMAP_ON

	 UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
	 #ifdef FOG_COMBINED_WITH_TSPACE
	   UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
	 #elif defined (FOG_COMBINED_WITH_WORLD_POS)
	   UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
	 #else
	   UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
	 #endif
	 return o;
   }

   // fragment shader
   fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
	 UNITY_SETUP_INSTANCE_ID(IN);
   // prepare and unpack data
   Input surfIN;
   #ifdef FOG_COMBINED_WITH_TSPACE
	 UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
   #elif defined (FOG_COMBINED_WITH_WORLD_POS)
	 UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
   #else
	 UNITY_EXTRACT_FOG(IN);
   #endif
   #ifdef FOG_COMBINED_WITH_TSPACE
	 UNITY_RECONSTRUCT_TBN(IN);
   #else
	 UNITY_EXTRACT_TBN(IN);
   #endif
   UNITY_INITIALIZE_OUTPUT(Input,surfIN);
   surfIN.uv_texcoord.x = 1.0;
   surfIN.ASEVFace.x = 1.0;
   surfIN.vertexColor.x = 1.0;
   surfIN.uv4_texcoord4.x = 1.0;
   surfIN.screenPosition.x = 1.0;
   surfIN.uv_texcoord = IN.pack0.xy;
   surfIN.uv4_texcoord4 = IN.pack0.zw;
   surfIN.screenPosition = IN.custompack0.xyzw;
   float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
   #ifndef USING_DIRECTIONAL_LIGHT
	 fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
   #else
	 fixed3 lightDir = _WorldSpaceLightPos0.xyz;
   #endif
   float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
   surfIN.vertexColor = IN.color;
   #if UNITY_VFACE_FLIPPED
	  vface = -vface;
   #endif
   surfIN.ASEVFace = vface;
   #ifdef UNITY_COMPILER_HLSL
   SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
   #else
   SurfaceOutputStandardCustom o;
   #endif
   o.Albedo = 0.0;
   o.Emission = 0.0;
   o.Alpha = 0.0;
   o.Occlusion = 1.0;
   fixed3 normalWorldVertex = fixed3(0,0,1);
   o.Normal = fixed3(0,0,1);

   // call surface function
   surf(surfIN, o);

   // compute lighting & shadowing factor
   UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
   fixed4 c = 0;
   float3 worldN;
   worldN.x = dot(_unity_tbn_0, o.Normal);
   worldN.y = dot(_unity_tbn_1, o.Normal);
   worldN.z = dot(_unity_tbn_2, o.Normal);
   worldN = normalize(worldN);
   o.Normal = worldN;

   // Setup lighting environment
   UnityGI gi;
   UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
   gi.indirect.diffuse = 0;
   gi.indirect.specular = 0;
   gi.light.color = _LightColor0.rgb;
   gi.light.dir = lightDir;
   // Call GI (lightmaps/SH/reflections) lighting function
   UnityGIInput giInput;
   UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
   giInput.light = gi.light;
   giInput.worldPos = worldPos;
   giInput.worldViewDir = worldViewDir;
   giInput.atten = atten;
   #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
	 giInput.lightmapUV = IN.lmap;
   #else
	 giInput.lightmapUV = 0.0;
   #endif
   #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
	 giInput.ambient = IN.sh;
   #else
	 giInput.ambient.rgb = 0.0;
   #endif
   giInput.probeHDR[0] = unity_SpecCube0_HDR;
   giInput.probeHDR[1] = unity_SpecCube1_HDR;
   #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
	 giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
   #endif
   #ifdef UNITY_SPECCUBE_BOX_PROJECTION
	 giInput.boxMax[0] = unity_SpecCube0_BoxMax;
	 giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
	 giInput.boxMax[1] = unity_SpecCube1_BoxMax;
	 giInput.boxMin[1] = unity_SpecCube1_BoxMin;
	 giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
   #endif
   LightingStandardCustom_GI(o, giInput, gi);

   // realtime lighting: call lighting function
   c += LightingStandardCustom(o, worldViewDir, gi);
   UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
   return c;
 }


 #endif

	   // -------- variant for: _GLOSSYREFLECTIONS_OFF INSTANCING_ON 
	   #if defined(_GLOSSYREFLECTIONS_OFF) && defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_SPECULARHIGHLIGHTS_OFF)
	   // Surface shader code generated based on:
	   // vertex modifier: 'vertexDataFunc'
	   // writes to per-pixel normal: YES
	   // writes to emission: no
	   // writes to occlusion: YES
	   // needs world space reflection vector: no
	   // needs world space normal vector: no
	   // needs screen space position: no
	   // needs world space position: no
	   // needs view direction: no
	   // needs world space view direction: no
	   // needs world space position for lighting: YES
	   // needs world space view direction for lighting: YES
	   // needs world space view direction for lightmaps: no
	   // needs vertex color: YES
	   // needs VFACE: YES
	   // passes tangent-to-world matrix to pixel shader: YES
	   // reads from normal: no
	   // 2 texcoords actually used
	   //   float2 _texcoord
	   //   float2 _texcoord4
	   #include "UnityCG.cginc"
	   #include "Lighting.cginc"
	   #include "AutoLight.cginc"

	   #define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
	   #define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
	   #define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

	   // Original surface shader snippet:
	   #line 48 ""
	   #ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
	   #endif
	   /* UNITY: Original start of shader */
			   #include "UnityShaderVariables.cginc"
			   #include "UnityStandardUtils.cginc"
			   #include "UnityPBSLighting.cginc"
			   //#pragma target 3.0
			   //#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
			   //#pragma shader_feature _GLOSSYREFLECTIONS_OFF
			   //#pragma multi_compile __ LOD_FADE_CROSSFADE
			   //#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
			   struct Input
			   {
				   float2 uv_texcoord;
				   half ASEVFace : VFACE;
				   float4 vertexColor : COLOR;
				   float2 uv4_texcoord4;
				   float4 screenPosition;
			   };

			   struct SurfaceOutputStandardCustom
			   {
				   half3 Albedo;
				   half3 Normal;
				   half3 Emission;
				   half Metallic;
				   half Smoothness;
				   half Occlusion;
				   half Alpha;
				   half3 Transmission;
				   half3 Translucency;
			   };

			   uniform int _WindModeLeaves;
			   uniform float _WindStrength;
			   uniform float _GlobalWindInfluence;
			   uniform float _RandomWindOffset;
			   uniform float _WindPulse;
			   uniform float _WindDirection;
			   uniform float _WindTurbulence;
			   uniform float _GlobalTurbulenceInfluence;
			   uniform int _DoubleSidedNormalMode;
			   uniform int _CullMode;
			   uniform sampler2D _BumpMap;
			   uniform float4 _BumpMap_ST;
			   uniform half _BumpScale;
			   uniform float _ColorVariation;
			   uniform half _Hue;
			   uniform float4 _Color;
			   uniform sampler2D _MainTex;
			   uniform float4 _MainTex_ST;
			   uniform float _Saturation;
			   uniform float _Value;
			   uniform int _ColorShifting;
			   uniform float _Metallic;
			   uniform float _Glossiness;
			   uniform half _OcclusionStrength;
			   uniform float4 _TransmissionTint;
			   uniform half _Translucency;
			   uniform half _TransNormalDistortion;
			   uniform half _TransScattering;
			   uniform half _TransDirect;
			   uniform half _TransAmbient;
			   uniform half _TransShadow;
			   uniform float4 _TranslucencyTint;
			   uniform half _Cutoff;


			   float2 DirectionalEquation(float _WindDirection)
			   {
				   float d = _WindDirection * 0.0174532924;
				   float xL = cos(d) + 1 / 2;
				   float zL = sin(d) + 1 / 2;
				   return float2(zL,xL);
			   }


			   float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
			   {
				   float3 Output = m_None;
				   if (m_Switch == 0) { Output = m_Leaves; }
				   if (m_Switch == 1) { Output = m_Palm; }
				   if (m_Switch == 2) { Output = m_Grass; }
				   if (m_Switch == 3) { Output = m_None; }
				   return Output;
			   }


			   float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
			   {
				   float3 OUT = None;
				   if (Cull == 0) {
					   if (Mode == 0)
						   OUT = Flip;
					   if (Mode == 1)
						   OUT = Mirror;
					   if (Mode == 2)
						   OUT == None;
				   }
	   else {
		  OUT = None;
	  }
	  return OUT;
  }


  float3 HSVToRGB(float3 c)
  {
	  float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	  float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	  return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
  }


  float3 RGBToHSV(float3 c)
  {
	  float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	  float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	  float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	  float d = q.x - min(q.w, q.y);
	  float e = 1.0e-10;
	  return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
  }

  inline float Dither8x8Bayer(int x, int y)
  {
	  const float dither[64] = {
		   1, 49, 13, 61,  4, 52, 16, 64,
		  33, 17, 45, 29, 36, 20, 48, 32,
		   9, 57,  5, 53, 12, 60,  8, 56,
		  41, 25, 37, 21, 44, 28, 40, 24,
		   3, 51, 15, 63,  2, 50, 14, 62,
		  35, 19, 47, 31, 34, 18, 46, 30,
		  11, 59,  7, 55, 10, 58,  6, 54,
		  43, 27, 39, 23, 42, 26, 38, 22};
	  int r = y * 8 + x;
	  return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
  }


  void vertexDataFunc(inout appdata_full v, out Input o)
  {
	  UNITY_INITIALIZE_OUTPUT(Input, o);
	  int m_Switch252_g490 = _WindModeLeaves;
	  float3 ase_vertex3Pos = v.vertex.xyz;
	  float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	  float3 break109_g490 = VAR_VertexPosition21_g490;
	  float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	  float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	  float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	  float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	  float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	  float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	  float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	  float VAR_WindPulse274_g490 = _WindPulse;
	  float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	  float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	  float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	  float _WindDirection164_g490 = _WindDirection;
	  float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	  float2 break165_g490 = localDirectionalEquation164_g490;
	  float VAR_xLerp83_g490 = break165_g490.x;
	  float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	  float3 break98_g490 = VAR_VertexPosition21_g490;
	  float3 break105_g490 = VAR_VertexPosition21_g490;
	  float VAR_zLerp95_g490 = break165_g490.y;
	  float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	  float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	  float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	  float3 break236_g490 = FUNC_vertexPos123_g490;
	  half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	  float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	  float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	  float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	  float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	  float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	  float3 ase_normWorldNormal = normalize(ase_worldNormal);
	  float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	  float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	  float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	  float3 break221_g490 = FUNC_vertexPos123_g490;
	  float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	  float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	  float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	  float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	  float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	  float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	  float3 m_None252_g490 = FUNC_vertexPos123_g490;
	  float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	  float3 OUT_Leafs262_g490 = localIf252_g490;
	  float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	  float3 OUT_VertexPos261 = temp_output_5_0_g490;
	  v.vertex.xyz = OUT_VertexPos261;
	  float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	  o.screenPosition = ase_screenPos;
  }

  inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
  {
	  #if !DIRECTIONAL
	  float3 lightAtten = gi.light.color;
	  #else
	  float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	  #endif
	  half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	  half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	  half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	  half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	  half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	  half4 d = half4(s.Albedo * transmission , 0);

	  SurfaceOutputStandard r;
	  r.Albedo = s.Albedo;
	  r.Normal = s.Normal;
	  r.Emission = s.Emission;
	  r.Metallic = s.Metallic;
	  r.Smoothness = s.Smoothness;
	  r.Occlusion = s.Occlusion;
	  r.Alpha = s.Alpha;
	  return LightingStandard(r, viewDir, gi) + c + d;
  }

  inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
  {
	  #if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		  gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	  #else
		  UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		  gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	  #endif
  }

  void surf(Input i , inout SurfaceOutputStandardCustom o)
  {
	  float Mode4_g488 = (float)_DoubleSidedNormalMode;
	  float Cull4_g488 = (float)_CullMode;
	  float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	  float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	  float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	  float3 break7_g488 = bump5_g488;
	  float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	  float3 Mirror4_g488 = appendResult11_g488;
	  float3 None4_g488 = bump5_g488;
	  float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	  float3 OUT_Normal255 = localIf4_g488;
	  o.Normal = OUT_Normal255;
	  float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	  float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	  float4 VAR_AlbedoTexture267 = tex2DNode13;
	  float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	  float4 VAR_Albedo18_g489 = VAR_Albedo101;
	  float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	  float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	  float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	  float4 OUT_Albedo254 = lerpResult19_g489;
	  o.Albedo = OUT_Albedo254.rgb;
	  o.Metallic = _Metallic;
	  float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	  float OUT_Smoothness50 = lerpResult268;
	  o.Smoothness = OUT_Smoothness50;
	  float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	  float OUT_AO44 = lerpResult41;
	  o.Occlusion = OUT_AO44;
	  float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	  #if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	  float4 ase_lightColor = 0;
	  #else //aselc
	  float4 ase_lightColor = _LightColor0;
	  #endif //aselc
	  float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	  float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	  o.Transmission = OUT_Transmission350;
	  float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	  o.Translucency = OUT_Translucency275;
	  clip(tex2DNode13.a - _Cutoff);
	  float temp_output_41_0_g487 = tex2DNode13.a;
	  float4 ase_screenPos = i.screenPosition;
	  float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	  ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	  float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	  float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	  dither45_g487 = step(dither45_g487, unity_LODFade.x);
	  #ifdef LOD_FADE_CROSSFADE
		  float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	  #else
		  float staticSwitch40_g487 = temp_output_41_0_g487;
	  #endif
	  float OUT_Alpha46 = staticSwitch40_g487;
	  o.Alpha = OUT_Alpha46;
  }



  // vertex-to-fragment interpolation data
  // no lightmaps:
  #ifndef LIGHTMAP_ON
  // half-precision fragment shader registers:
  #ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
  #define FOG_COMBINED_WITH_TSPACE
  struct v2f_surf {
	UNITY_POSITION(pos);
	float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
	float4 tSpace0 : TEXCOORD1;
	float4 tSpace1 : TEXCOORD2;
	float4 tSpace2 : TEXCOORD3;
	fixed4 color : COLOR0;
	float4 custompack0 : TEXCOORD4; // screenPosition
	#if UNITY_SHOULD_SAMPLE_SH
	half3 sh : TEXCOORD5; // SH
	#endif
	UNITY_LIGHTING_COORDS(6,7)
	#if SHADER_TARGET >= 30
	float4 lmap : TEXCOORD8;
	#endif
	UNITY_VERTEX_INPUT_INSTANCE_ID
	UNITY_VERTEX_OUTPUT_STEREO
  };
  #endif
  // high-precision fragment shader registers:
  #ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
  struct v2f_surf {
	UNITY_POSITION(pos);
	float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
	float4 tSpace0 : TEXCOORD1;
	float4 tSpace1 : TEXCOORD2;
	float4 tSpace2 : TEXCOORD3;
	fixed4 color : COLOR0;
	float4 custompack0 : TEXCOORD4; // screenPosition
	#if UNITY_SHOULD_SAMPLE_SH
	half3 sh : TEXCOORD5; // SH
	#endif
	UNITY_FOG_COORDS(6)
	UNITY_SHADOW_COORDS(7)
	#if SHADER_TARGET >= 30
	float4 lmap : TEXCOORD8;
	#endif
	UNITY_VERTEX_INPUT_INSTANCE_ID
	UNITY_VERTEX_OUTPUT_STEREO
  };
  #endif
  #endif
  // with lightmaps:
  #ifdef LIGHTMAP_ON
  // half-precision fragment shader registers:
  #ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
  #define FOG_COMBINED_WITH_TSPACE
  struct v2f_surf {
	UNITY_POSITION(pos);
	float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
	float4 tSpace0 : TEXCOORD1;
	float4 tSpace1 : TEXCOORD2;
	float4 tSpace2 : TEXCOORD3;
	fixed4 color : COLOR0;
	float4 custompack0 : TEXCOORD4; // screenPosition
	float4 lmap : TEXCOORD5;
	UNITY_LIGHTING_COORDS(6,7)
	UNITY_VERTEX_INPUT_INSTANCE_ID
	UNITY_VERTEX_OUTPUT_STEREO
  };
  #endif
  // high-precision fragment shader registers:
  #ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
  struct v2f_surf {
	UNITY_POSITION(pos);
	float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
	float4 tSpace0 : TEXCOORD1;
	float4 tSpace1 : TEXCOORD2;
	float4 tSpace2 : TEXCOORD3;
	fixed4 color : COLOR0;
	float4 custompack0 : TEXCOORD4; // screenPosition
	float4 lmap : TEXCOORD5;
	UNITY_FOG_COORDS(6)
	UNITY_SHADOW_COORDS(7)
	UNITY_VERTEX_INPUT_INSTANCE_ID
	UNITY_VERTEX_OUTPUT_STEREO
  };
  #endif
  #endif
  float4 _texcoord_ST;
  float4 _texcoord4_ST;

  // vertex shader
  v2f_surf vert_surf(appdata_full v) {
	UNITY_SETUP_INSTANCE_ID(v);
	v2f_surf o;
	UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
	UNITY_TRANSFER_INSTANCE_ID(v,o);
	UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
	Input customInputData;
	vertexDataFunc(v, customInputData);
	o.custompack0.xyzw = customInputData.screenPosition;
	o.pos = UnityObjectToClipPos(v.vertex);
	o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
	o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
	float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
	float3 worldNormal = UnityObjectToWorldNormal(v.normal);
	fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
	fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
	fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
	o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
	o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
	o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
	o.color = v.color;
	#ifdef DYNAMICLIGHTMAP_ON
	o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
	#endif
	#ifdef LIGHTMAP_ON
	o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	#endif

	// SH/ambient and vertex lights
	#ifndef LIGHTMAP_ON
	  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
		o.sh = 0;
		// Approximated illumination from non-important point lights
		#ifdef VERTEXLIGHT_ON
		  o.sh += Shade4PointLights(
			unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
			unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
			unity_4LightAtten0, worldPos, worldNormal);
		#endif
		o.sh = ShadeSHPerVertex(worldNormal, o.sh);
	  #endif
	#endif // !LIGHTMAP_ON

	UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
	#ifdef FOG_COMBINED_WITH_TSPACE
	  UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
	#elif defined (FOG_COMBINED_WITH_WORLD_POS)
	  UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
	#else
	  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
	#endif
	return o;
  }

  // fragment shader
  fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
	UNITY_SETUP_INSTANCE_ID(IN);
  // prepare and unpack data
  Input surfIN;
  #ifdef FOG_COMBINED_WITH_TSPACE
	UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
	UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
  #else
	UNITY_EXTRACT_FOG(IN);
  #endif
  #ifdef FOG_COMBINED_WITH_TSPACE
	UNITY_RECONSTRUCT_TBN(IN);
  #else
	UNITY_EXTRACT_TBN(IN);
  #endif
  UNITY_INITIALIZE_OUTPUT(Input,surfIN);
  surfIN.uv_texcoord.x = 1.0;
  surfIN.ASEVFace.x = 1.0;
  surfIN.vertexColor.x = 1.0;
  surfIN.uv4_texcoord4.x = 1.0;
  surfIN.screenPosition.x = 1.0;
  surfIN.uv_texcoord = IN.pack0.xy;
  surfIN.uv4_texcoord4 = IN.pack0.zw;
  surfIN.screenPosition = IN.custompack0.xyzw;
  float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
  #ifndef USING_DIRECTIONAL_LIGHT
	fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
  #else
	fixed3 lightDir = _WorldSpaceLightPos0.xyz;
  #endif
  float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
  surfIN.vertexColor = IN.color;
  #if UNITY_VFACE_FLIPPED
	 vface = -vface;
  #endif
  surfIN.ASEVFace = vface;
  #ifdef UNITY_COMPILER_HLSL
  SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
  #else
  SurfaceOutputStandardCustom o;
  #endif
  o.Albedo = 0.0;
  o.Emission = 0.0;
  o.Alpha = 0.0;
  o.Occlusion = 1.0;
  fixed3 normalWorldVertex = fixed3(0,0,1);
  o.Normal = fixed3(0,0,1);

  // call surface function
  surf(surfIN, o);

  // compute lighting & shadowing factor
  UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
  fixed4 c = 0;
  float3 worldN;
  worldN.x = dot(_unity_tbn_0, o.Normal);
  worldN.y = dot(_unity_tbn_1, o.Normal);
  worldN.z = dot(_unity_tbn_2, o.Normal);
  worldN = normalize(worldN);
  o.Normal = worldN;

  // Setup lighting environment
  UnityGI gi;
  UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
  gi.indirect.diffuse = 0;
  gi.indirect.specular = 0;
  gi.light.color = _LightColor0.rgb;
  gi.light.dir = lightDir;
  // Call GI (lightmaps/SH/reflections) lighting function
  UnityGIInput giInput;
  UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
  giInput.light = gi.light;
  giInput.worldPos = worldPos;
  giInput.worldViewDir = worldViewDir;
  giInput.atten = atten;
  #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
	giInput.lightmapUV = IN.lmap;
  #else
	giInput.lightmapUV = 0.0;
  #endif
  #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
	giInput.ambient = IN.sh;
  #else
	giInput.ambient.rgb = 0.0;
  #endif
  giInput.probeHDR[0] = unity_SpecCube0_HDR;
  giInput.probeHDR[1] = unity_SpecCube1_HDR;
  #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
	giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
  #endif
  #ifdef UNITY_SPECCUBE_BOX_PROJECTION
	giInput.boxMax[0] = unity_SpecCube0_BoxMax;
	giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
	giInput.boxMax[1] = unity_SpecCube1_BoxMax;
	giInput.boxMin[1] = unity_SpecCube1_BoxMin;
	giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
  #endif
  LightingStandardCustom_GI(o, giInput, gi);

  // realtime lighting: call lighting function
  c += LightingStandardCustom(o, worldViewDir, gi);
  UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
  return c;
}


#endif

// -------- variant for: _GLOSSYREFLECTIONS_OFF LOD_FADE_CROSSFADE 
#if defined(_GLOSSYREFLECTIONS_OFF) && defined(LOD_FADE_CROSSFADE) && !defined(INSTANCING_ON) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord4
#include "UnityCG.cginc"
#include "Lighting.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_LIGHTING_COORDS(6,7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_LIGHTING_COORDS(6,7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord4_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
	#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
	  o.sh = 0;
	  // Approximated illumination from non-important point lights
	  #ifdef VERTEXLIGHT_ON
		o.sh += Shade4PointLights(
		  unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
		  unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
		  unity_4LightAtten0, worldPos, worldNormal);
	  #endif
	  o.sh = ShadeSHPerVertex(worldNormal, o.sh);
	#endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
	UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
	UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
	UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.uv4_texcoord4 = IN.pack0.zw;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
surfIN.vertexColor = IN.color;
#if UNITY_VFACE_FLIPPED
   vface = -vface;
#endif
surfIN.ASEVFace = vface;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = fixed3(0,0,1);

// call surface function
surf(surfIN, o);

// compute lighting & shadowing factor
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
fixed4 c = 0;
float3 worldN;
worldN.x = dot(_unity_tbn_0, o.Normal);
worldN.y = dot(_unity_tbn_1, o.Normal);
worldN.z = dot(_unity_tbn_2, o.Normal);
worldN = normalize(worldN);
o.Normal = worldN;

// Setup lighting environment
UnityGI gi;
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
gi.indirect.diffuse = 0;
gi.indirect.specular = 0;
gi.light.color = _LightColor0.rgb;
gi.light.dir = lightDir;
// Call GI (lightmaps/SH/reflections) lighting function
UnityGIInput giInput;
UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
giInput.light = gi.light;
giInput.worldPos = worldPos;
giInput.worldViewDir = worldViewDir;
giInput.atten = atten;
#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
  giInput.lightmapUV = IN.lmap;
#else
  giInput.lightmapUV = 0.0;
#endif
#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
  giInput.ambient = IN.sh;
#else
  giInput.ambient.rgb = 0.0;
#endif
giInput.probeHDR[0] = unity_SpecCube0_HDR;
giInput.probeHDR[1] = unity_SpecCube1_HDR;
#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
  giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
#endif
#ifdef UNITY_SPECCUBE_BOX_PROJECTION
  giInput.boxMax[0] = unity_SpecCube0_BoxMax;
  giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
  giInput.boxMax[1] = unity_SpecCube1_BoxMax;
  giInput.boxMin[1] = unity_SpecCube1_BoxMin;
  giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
#endif
LightingStandardCustom_GI(o, giInput, gi);

// realtime lighting: call lighting function
c += LightingStandardCustom(o, worldViewDir, gi);
UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
return c;
}


#endif

// -------- variant for: _GLOSSYREFLECTIONS_OFF LOD_FADE_CROSSFADE INSTANCING_ON 
#if defined(_GLOSSYREFLECTIONS_OFF) && defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord4
#include "UnityCG.cginc"
#include "Lighting.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_LIGHTING_COORDS(6,7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_LIGHTING_COORDS(6,7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord4_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
	#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
	  o.sh = 0;
	  // Approximated illumination from non-important point lights
	  #ifdef VERTEXLIGHT_ON
		o.sh += Shade4PointLights(
		  unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
		  unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
		  unity_4LightAtten0, worldPos, worldNormal);
	  #endif
	  o.sh = ShadeSHPerVertex(worldNormal, o.sh);
	#endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
	UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
	UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
	UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.uv4_texcoord4 = IN.pack0.zw;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
surfIN.vertexColor = IN.color;
#if UNITY_VFACE_FLIPPED
   vface = -vface;
#endif
surfIN.ASEVFace = vface;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = fixed3(0,0,1);

// call surface function
surf(surfIN, o);

// compute lighting & shadowing factor
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
fixed4 c = 0;
float3 worldN;
worldN.x = dot(_unity_tbn_0, o.Normal);
worldN.y = dot(_unity_tbn_1, o.Normal);
worldN.z = dot(_unity_tbn_2, o.Normal);
worldN = normalize(worldN);
o.Normal = worldN;

// Setup lighting environment
UnityGI gi;
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
gi.indirect.diffuse = 0;
gi.indirect.specular = 0;
gi.light.color = _LightColor0.rgb;
gi.light.dir = lightDir;
// Call GI (lightmaps/SH/reflections) lighting function
UnityGIInput giInput;
UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
giInput.light = gi.light;
giInput.worldPos = worldPos;
giInput.worldViewDir = worldViewDir;
giInput.atten = atten;
#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
  giInput.lightmapUV = IN.lmap;
#else
  giInput.lightmapUV = 0.0;
#endif
#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
  giInput.ambient = IN.sh;
#else
  giInput.ambient.rgb = 0.0;
#endif
giInput.probeHDR[0] = unity_SpecCube0_HDR;
giInput.probeHDR[1] = unity_SpecCube1_HDR;
#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
  giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
#endif
#ifdef UNITY_SPECCUBE_BOX_PROJECTION
  giInput.boxMax[0] = unity_SpecCube0_BoxMax;
  giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
  giInput.boxMax[1] = unity_SpecCube1_BoxMax;
  giInput.boxMin[1] = unity_SpecCube1_BoxMin;
  giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
#endif
LightingStandardCustom_GI(o, giInput, gi);

// realtime lighting: call lighting function
c += LightingStandardCustom(o, worldViewDir, gi);
UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
return c;
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF 
#if defined(_SPECULARHIGHLIGHTS_OFF) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_GLOSSYREFLECTIONS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord4
#include "UnityCG.cginc"
#include "Lighting.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_LIGHTING_COORDS(6,7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_LIGHTING_COORDS(6,7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord4_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
	#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
	  o.sh = 0;
	  // Approximated illumination from non-important point lights
	  #ifdef VERTEXLIGHT_ON
		o.sh += Shade4PointLights(
		  unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
		  unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
		  unity_4LightAtten0, worldPos, worldNormal);
	  #endif
	  o.sh = ShadeSHPerVertex(worldNormal, o.sh);
	#endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
	UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
	UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
	UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.uv4_texcoord4 = IN.pack0.zw;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
surfIN.vertexColor = IN.color;
#if UNITY_VFACE_FLIPPED
   vface = -vface;
#endif
surfIN.ASEVFace = vface;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = fixed3(0,0,1);

// call surface function
surf(surfIN, o);

// compute lighting & shadowing factor
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
fixed4 c = 0;
float3 worldN;
worldN.x = dot(_unity_tbn_0, o.Normal);
worldN.y = dot(_unity_tbn_1, o.Normal);
worldN.z = dot(_unity_tbn_2, o.Normal);
worldN = normalize(worldN);
o.Normal = worldN;

// Setup lighting environment
UnityGI gi;
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
gi.indirect.diffuse = 0;
gi.indirect.specular = 0;
gi.light.color = _LightColor0.rgb;
gi.light.dir = lightDir;
// Call GI (lightmaps/SH/reflections) lighting function
UnityGIInput giInput;
UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
giInput.light = gi.light;
giInput.worldPos = worldPos;
giInput.worldViewDir = worldViewDir;
giInput.atten = atten;
#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
  giInput.lightmapUV = IN.lmap;
#else
  giInput.lightmapUV = 0.0;
#endif
#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
  giInput.ambient = IN.sh;
#else
  giInput.ambient.rgb = 0.0;
#endif
giInput.probeHDR[0] = unity_SpecCube0_HDR;
giInput.probeHDR[1] = unity_SpecCube1_HDR;
#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
  giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
#endif
#ifdef UNITY_SPECCUBE_BOX_PROJECTION
  giInput.boxMax[0] = unity_SpecCube0_BoxMax;
  giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
  giInput.boxMax[1] = unity_SpecCube1_BoxMax;
  giInput.boxMin[1] = unity_SpecCube1_BoxMin;
  giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
#endif
LightingStandardCustom_GI(o, giInput, gi);

// realtime lighting: call lighting function
c += LightingStandardCustom(o, worldViewDir, gi);
UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
return c;
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF INSTANCING_ON 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_GLOSSYREFLECTIONS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord4
#include "UnityCG.cginc"
#include "Lighting.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_LIGHTING_COORDS(6,7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_LIGHTING_COORDS(6,7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord4_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
	#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
	  o.sh = 0;
	  // Approximated illumination from non-important point lights
	  #ifdef VERTEXLIGHT_ON
		o.sh += Shade4PointLights(
		  unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
		  unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
		  unity_4LightAtten0, worldPos, worldNormal);
	  #endif
	  o.sh = ShadeSHPerVertex(worldNormal, o.sh);
	#endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
	UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
	UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
	UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.uv4_texcoord4 = IN.pack0.zw;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
surfIN.vertexColor = IN.color;
#if UNITY_VFACE_FLIPPED
   vface = -vface;
#endif
surfIN.ASEVFace = vface;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = fixed3(0,0,1);

// call surface function
surf(surfIN, o);

// compute lighting & shadowing factor
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
fixed4 c = 0;
float3 worldN;
worldN.x = dot(_unity_tbn_0, o.Normal);
worldN.y = dot(_unity_tbn_1, o.Normal);
worldN.z = dot(_unity_tbn_2, o.Normal);
worldN = normalize(worldN);
o.Normal = worldN;

// Setup lighting environment
UnityGI gi;
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
gi.indirect.diffuse = 0;
gi.indirect.specular = 0;
gi.light.color = _LightColor0.rgb;
gi.light.dir = lightDir;
// Call GI (lightmaps/SH/reflections) lighting function
UnityGIInput giInput;
UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
giInput.light = gi.light;
giInput.worldPos = worldPos;
giInput.worldViewDir = worldViewDir;
giInput.atten = atten;
#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
  giInput.lightmapUV = IN.lmap;
#else
  giInput.lightmapUV = 0.0;
#endif
#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
  giInput.ambient = IN.sh;
#else
  giInput.ambient.rgb = 0.0;
#endif
giInput.probeHDR[0] = unity_SpecCube0_HDR;
giInput.probeHDR[1] = unity_SpecCube1_HDR;
#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
  giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
#endif
#ifdef UNITY_SPECCUBE_BOX_PROJECTION
  giInput.boxMax[0] = unity_SpecCube0_BoxMax;
  giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
  giInput.boxMax[1] = unity_SpecCube1_BoxMax;
  giInput.boxMin[1] = unity_SpecCube1_BoxMin;
  giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
#endif
LightingStandardCustom_GI(o, giInput, gi);

// realtime lighting: call lighting function
c += LightingStandardCustom(o, worldViewDir, gi);
UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
return c;
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF LOD_FADE_CROSSFADE 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(LOD_FADE_CROSSFADE) && !defined(INSTANCING_ON) && !defined(_GLOSSYREFLECTIONS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord4
#include "UnityCG.cginc"
#include "Lighting.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_LIGHTING_COORDS(6,7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_LIGHTING_COORDS(6,7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord4_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
	#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
	  o.sh = 0;
	  // Approximated illumination from non-important point lights
	  #ifdef VERTEXLIGHT_ON
		o.sh += Shade4PointLights(
		  unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
		  unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
		  unity_4LightAtten0, worldPos, worldNormal);
	  #endif
	  o.sh = ShadeSHPerVertex(worldNormal, o.sh);
	#endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
	UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
	UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
	UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.uv4_texcoord4 = IN.pack0.zw;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
surfIN.vertexColor = IN.color;
#if UNITY_VFACE_FLIPPED
   vface = -vface;
#endif
surfIN.ASEVFace = vface;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = fixed3(0,0,1);

// call surface function
surf(surfIN, o);

// compute lighting & shadowing factor
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
fixed4 c = 0;
float3 worldN;
worldN.x = dot(_unity_tbn_0, o.Normal);
worldN.y = dot(_unity_tbn_1, o.Normal);
worldN.z = dot(_unity_tbn_2, o.Normal);
worldN = normalize(worldN);
o.Normal = worldN;

// Setup lighting environment
UnityGI gi;
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
gi.indirect.diffuse = 0;
gi.indirect.specular = 0;
gi.light.color = _LightColor0.rgb;
gi.light.dir = lightDir;
// Call GI (lightmaps/SH/reflections) lighting function
UnityGIInput giInput;
UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
giInput.light = gi.light;
giInput.worldPos = worldPos;
giInput.worldViewDir = worldViewDir;
giInput.atten = atten;
#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
  giInput.lightmapUV = IN.lmap;
#else
  giInput.lightmapUV = 0.0;
#endif
#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
  giInput.ambient = IN.sh;
#else
  giInput.ambient.rgb = 0.0;
#endif
giInput.probeHDR[0] = unity_SpecCube0_HDR;
giInput.probeHDR[1] = unity_SpecCube1_HDR;
#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
  giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
#endif
#ifdef UNITY_SPECCUBE_BOX_PROJECTION
  giInput.boxMax[0] = unity_SpecCube0_BoxMax;
  giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
  giInput.boxMax[1] = unity_SpecCube1_BoxMax;
  giInput.boxMin[1] = unity_SpecCube1_BoxMin;
  giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
#endif
LightingStandardCustom_GI(o, giInput, gi);

// realtime lighting: call lighting function
c += LightingStandardCustom(o, worldViewDir, gi);
UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
return c;
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF LOD_FADE_CROSSFADE INSTANCING_ON 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && !defined(_GLOSSYREFLECTIONS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord4
#include "UnityCG.cginc"
#include "Lighting.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_LIGHTING_COORDS(6,7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_LIGHTING_COORDS(6,7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord4_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
	#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
	  o.sh = 0;
	  // Approximated illumination from non-important point lights
	  #ifdef VERTEXLIGHT_ON
		o.sh += Shade4PointLights(
		  unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
		  unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
		  unity_4LightAtten0, worldPos, worldNormal);
	  #endif
	  o.sh = ShadeSHPerVertex(worldNormal, o.sh);
	#endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
	UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
	UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
	UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.uv4_texcoord4 = IN.pack0.zw;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
surfIN.vertexColor = IN.color;
#if UNITY_VFACE_FLIPPED
   vface = -vface;
#endif
surfIN.ASEVFace = vface;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = fixed3(0,0,1);

// call surface function
surf(surfIN, o);

// compute lighting & shadowing factor
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
fixed4 c = 0;
float3 worldN;
worldN.x = dot(_unity_tbn_0, o.Normal);
worldN.y = dot(_unity_tbn_1, o.Normal);
worldN.z = dot(_unity_tbn_2, o.Normal);
worldN = normalize(worldN);
o.Normal = worldN;

// Setup lighting environment
UnityGI gi;
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
gi.indirect.diffuse = 0;
gi.indirect.specular = 0;
gi.light.color = _LightColor0.rgb;
gi.light.dir = lightDir;
// Call GI (lightmaps/SH/reflections) lighting function
UnityGIInput giInput;
UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
giInput.light = gi.light;
giInput.worldPos = worldPos;
giInput.worldViewDir = worldViewDir;
giInput.atten = atten;
#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
  giInput.lightmapUV = IN.lmap;
#else
  giInput.lightmapUV = 0.0;
#endif
#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
  giInput.ambient = IN.sh;
#else
  giInput.ambient.rgb = 0.0;
#endif
giInput.probeHDR[0] = unity_SpecCube0_HDR;
giInput.probeHDR[1] = unity_SpecCube1_HDR;
#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
  giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
#endif
#ifdef UNITY_SPECCUBE_BOX_PROJECTION
  giInput.boxMax[0] = unity_SpecCube0_BoxMax;
  giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
  giInput.boxMax[1] = unity_SpecCube1_BoxMax;
  giInput.boxMin[1] = unity_SpecCube1_BoxMin;
  giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
#endif
LightingStandardCustom_GI(o, giInput, gi);

// realtime lighting: call lighting function
c += LightingStandardCustom(o, worldViewDir, gi);
UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
return c;
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF _GLOSSYREFLECTIONS_OFF 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(_GLOSSYREFLECTIONS_OFF) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord4
#include "UnityCG.cginc"
#include "Lighting.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_LIGHTING_COORDS(6,7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_LIGHTING_COORDS(6,7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord4_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
	#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
	  o.sh = 0;
	  // Approximated illumination from non-important point lights
	  #ifdef VERTEXLIGHT_ON
		o.sh += Shade4PointLights(
		  unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
		  unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
		  unity_4LightAtten0, worldPos, worldNormal);
	  #endif
	  o.sh = ShadeSHPerVertex(worldNormal, o.sh);
	#endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
	UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
	UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
	UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.uv4_texcoord4 = IN.pack0.zw;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
surfIN.vertexColor = IN.color;
#if UNITY_VFACE_FLIPPED
   vface = -vface;
#endif
surfIN.ASEVFace = vface;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = fixed3(0,0,1);

// call surface function
surf(surfIN, o);

// compute lighting & shadowing factor
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
fixed4 c = 0;
float3 worldN;
worldN.x = dot(_unity_tbn_0, o.Normal);
worldN.y = dot(_unity_tbn_1, o.Normal);
worldN.z = dot(_unity_tbn_2, o.Normal);
worldN = normalize(worldN);
o.Normal = worldN;

// Setup lighting environment
UnityGI gi;
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
gi.indirect.diffuse = 0;
gi.indirect.specular = 0;
gi.light.color = _LightColor0.rgb;
gi.light.dir = lightDir;
// Call GI (lightmaps/SH/reflections) lighting function
UnityGIInput giInput;
UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
giInput.light = gi.light;
giInput.worldPos = worldPos;
giInput.worldViewDir = worldViewDir;
giInput.atten = atten;
#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
  giInput.lightmapUV = IN.lmap;
#else
  giInput.lightmapUV = 0.0;
#endif
#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
  giInput.ambient = IN.sh;
#else
  giInput.ambient.rgb = 0.0;
#endif
giInput.probeHDR[0] = unity_SpecCube0_HDR;
giInput.probeHDR[1] = unity_SpecCube1_HDR;
#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
  giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
#endif
#ifdef UNITY_SPECCUBE_BOX_PROJECTION
  giInput.boxMax[0] = unity_SpecCube0_BoxMax;
  giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
  giInput.boxMax[1] = unity_SpecCube1_BoxMax;
  giInput.boxMin[1] = unity_SpecCube1_BoxMin;
  giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
#endif
LightingStandardCustom_GI(o, giInput, gi);

// realtime lighting: call lighting function
c += LightingStandardCustom(o, worldViewDir, gi);
UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
return c;
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF _GLOSSYREFLECTIONS_OFF INSTANCING_ON 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(_GLOSSYREFLECTIONS_OFF) && defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord4
#include "UnityCG.cginc"
#include "Lighting.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_LIGHTING_COORDS(6,7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_LIGHTING_COORDS(6,7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord4_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
	#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
	  o.sh = 0;
	  // Approximated illumination from non-important point lights
	  #ifdef VERTEXLIGHT_ON
		o.sh += Shade4PointLights(
		  unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
		  unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
		  unity_4LightAtten0, worldPos, worldNormal);
	  #endif
	  o.sh = ShadeSHPerVertex(worldNormal, o.sh);
	#endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
	UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
	UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
	UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.uv4_texcoord4 = IN.pack0.zw;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
surfIN.vertexColor = IN.color;
#if UNITY_VFACE_FLIPPED
   vface = -vface;
#endif
surfIN.ASEVFace = vface;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = fixed3(0,0,1);

// call surface function
surf(surfIN, o);

// compute lighting & shadowing factor
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
fixed4 c = 0;
float3 worldN;
worldN.x = dot(_unity_tbn_0, o.Normal);
worldN.y = dot(_unity_tbn_1, o.Normal);
worldN.z = dot(_unity_tbn_2, o.Normal);
worldN = normalize(worldN);
o.Normal = worldN;

// Setup lighting environment
UnityGI gi;
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
gi.indirect.diffuse = 0;
gi.indirect.specular = 0;
gi.light.color = _LightColor0.rgb;
gi.light.dir = lightDir;
// Call GI (lightmaps/SH/reflections) lighting function
UnityGIInput giInput;
UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
giInput.light = gi.light;
giInput.worldPos = worldPos;
giInput.worldViewDir = worldViewDir;
giInput.atten = atten;
#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
  giInput.lightmapUV = IN.lmap;
#else
  giInput.lightmapUV = 0.0;
#endif
#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
  giInput.ambient = IN.sh;
#else
  giInput.ambient.rgb = 0.0;
#endif
giInput.probeHDR[0] = unity_SpecCube0_HDR;
giInput.probeHDR[1] = unity_SpecCube1_HDR;
#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
  giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
#endif
#ifdef UNITY_SPECCUBE_BOX_PROJECTION
  giInput.boxMax[0] = unity_SpecCube0_BoxMax;
  giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
  giInput.boxMax[1] = unity_SpecCube1_BoxMax;
  giInput.boxMin[1] = unity_SpecCube1_BoxMin;
  giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
#endif
LightingStandardCustom_GI(o, giInput, gi);

// realtime lighting: call lighting function
c += LightingStandardCustom(o, worldViewDir, gi);
UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
return c;
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF _GLOSSYREFLECTIONS_OFF LOD_FADE_CROSSFADE 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(_GLOSSYREFLECTIONS_OFF) && defined(LOD_FADE_CROSSFADE) && !defined(INSTANCING_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord4
#include "UnityCG.cginc"
#include "Lighting.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_LIGHTING_COORDS(6,7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_LIGHTING_COORDS(6,7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord4_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
	#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
	  o.sh = 0;
	  // Approximated illumination from non-important point lights
	  #ifdef VERTEXLIGHT_ON
		o.sh += Shade4PointLights(
		  unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
		  unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
		  unity_4LightAtten0, worldPos, worldNormal);
	  #endif
	  o.sh = ShadeSHPerVertex(worldNormal, o.sh);
	#endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
	UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
	UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
	UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.uv4_texcoord4 = IN.pack0.zw;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
surfIN.vertexColor = IN.color;
#if UNITY_VFACE_FLIPPED
   vface = -vface;
#endif
surfIN.ASEVFace = vface;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = fixed3(0,0,1);

// call surface function
surf(surfIN, o);

// compute lighting & shadowing factor
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
fixed4 c = 0;
float3 worldN;
worldN.x = dot(_unity_tbn_0, o.Normal);
worldN.y = dot(_unity_tbn_1, o.Normal);
worldN.z = dot(_unity_tbn_2, o.Normal);
worldN = normalize(worldN);
o.Normal = worldN;

// Setup lighting environment
UnityGI gi;
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
gi.indirect.diffuse = 0;
gi.indirect.specular = 0;
gi.light.color = _LightColor0.rgb;
gi.light.dir = lightDir;
// Call GI (lightmaps/SH/reflections) lighting function
UnityGIInput giInput;
UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
giInput.light = gi.light;
giInput.worldPos = worldPos;
giInput.worldViewDir = worldViewDir;
giInput.atten = atten;
#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
  giInput.lightmapUV = IN.lmap;
#else
  giInput.lightmapUV = 0.0;
#endif
#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
  giInput.ambient = IN.sh;
#else
  giInput.ambient.rgb = 0.0;
#endif
giInput.probeHDR[0] = unity_SpecCube0_HDR;
giInput.probeHDR[1] = unity_SpecCube1_HDR;
#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
  giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
#endif
#ifdef UNITY_SPECCUBE_BOX_PROJECTION
  giInput.boxMax[0] = unity_SpecCube0_BoxMax;
  giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
  giInput.boxMax[1] = unity_SpecCube1_BoxMax;
  giInput.boxMin[1] = unity_SpecCube1_BoxMin;
  giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
#endif
LightingStandardCustom_GI(o, giInput, gi);

// realtime lighting: call lighting function
c += LightingStandardCustom(o, worldViewDir, gi);
UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
return c;
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF _GLOSSYREFLECTIONS_OFF LOD_FADE_CROSSFADE INSTANCING_ON 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(_GLOSSYREFLECTIONS_OFF) && defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord4
#include "UnityCG.cginc"
#include "Lighting.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
// no lightmaps:
#ifndef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_LIGHTING_COORDS(6,7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  #if UNITY_SHOULD_SAMPLE_SH
  half3 sh : TEXCOORD5; // SH
  #endif
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  #if SHADER_TARGET >= 30
  float4 lmap : TEXCOORD8;
  #endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
// with lightmaps:
#ifdef LIGHTMAP_ON
// half-precision fragment shader registers:
#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
#define FOG_COMBINED_WITH_TSPACE
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_LIGHTING_COORDS(6,7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
// high-precision fragment shader registers:
#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
  float4 lmap : TEXCOORD5;
  UNITY_FOG_COORDS(6)
  UNITY_SHADOW_COORDS(7)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
#endif
#endif
float4 _texcoord_ST;
float4 _texcoord4_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  #ifdef DYNAMICLIGHTMAP_ON
  o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
  #endif
  #ifdef LIGHTMAP_ON
  o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
  #endif

  // SH/ambient and vertex lights
  #ifndef LIGHTMAP_ON
	#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
	  o.sh = 0;
	  // Approximated illumination from non-important point lights
	  #ifdef VERTEXLIGHT_ON
		o.sh += Shade4PointLights(
		  unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
		  unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
		  unity_4LightAtten0, worldPos, worldNormal);
	  #endif
	  o.sh = ShadeSHPerVertex(worldNormal, o.sh);
	#endif
  #endif // !LIGHTMAP_ON

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  #ifdef FOG_COMBINED_WITH_TSPACE
	UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
  #elif defined (FOG_COMBINED_WITH_WORLD_POS)
	UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
  #else
	UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  #endif
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.uv4_texcoord4 = IN.pack0.zw;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
surfIN.vertexColor = IN.color;
#if UNITY_VFACE_FLIPPED
   vface = -vface;
#endif
surfIN.ASEVFace = vface;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = fixed3(0,0,1);

// call surface function
surf(surfIN, o);

// compute lighting & shadowing factor
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
fixed4 c = 0;
float3 worldN;
worldN.x = dot(_unity_tbn_0, o.Normal);
worldN.y = dot(_unity_tbn_1, o.Normal);
worldN.z = dot(_unity_tbn_2, o.Normal);
worldN = normalize(worldN);
o.Normal = worldN;

// Setup lighting environment
UnityGI gi;
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
gi.indirect.diffuse = 0;
gi.indirect.specular = 0;
gi.light.color = _LightColor0.rgb;
gi.light.dir = lightDir;
// Call GI (lightmaps/SH/reflections) lighting function
UnityGIInput giInput;
UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
giInput.light = gi.light;
giInput.worldPos = worldPos;
giInput.worldViewDir = worldViewDir;
giInput.atten = atten;
#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
  giInput.lightmapUV = IN.lmap;
#else
  giInput.lightmapUV = 0.0;
#endif
#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
  giInput.ambient = IN.sh;
#else
  giInput.ambient.rgb = 0.0;
#endif
giInput.probeHDR[0] = unity_SpecCube0_HDR;
giInput.probeHDR[1] = unity_SpecCube1_HDR;
#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
  giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
#endif
#ifdef UNITY_SPECCUBE_BOX_PROJECTION
  giInput.boxMax[0] = unity_SpecCube0_BoxMax;
  giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
  giInput.boxMax[1] = unity_SpecCube1_BoxMax;
  giInput.boxMin[1] = unity_SpecCube1_BoxMin;
  giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
#endif
LightingStandardCustom_GI(o, giInput, gi);

// realtime lighting: call lighting function
c += LightingStandardCustom(o, worldViewDir, gi);
UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
return c;
}


#endif


ENDCG

}

// ---- forward rendering additive lights pass:
Pass {
	Name "FORWARD"
	Tags { "LightMode" = "ForwardAdd" }
	ZWrite Off Blend One One

CGPROGRAM
// compile directives
#pragma vertex vert_surf
#pragma fragment frag_surf
#pragma target 3.0
#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
#pragma shader_feature _GLOSSYREFLECTIONS_OFF
#pragma multi_compile __ LOD_FADE_CROSSFADE
#pragma multi_compile_instancing
#pragma multi_compile_fog
#pragma skip_variants INSTANCING_ON
#pragma multi_compile_fwdadd_fullshadows
#include "HLSLSupport.cginc"
#define UNITY_INSTANCED_LOD_FADE
#define UNITY_INSTANCED_SH
#define UNITY_INSTANCED_LIGHTMAPSTS
#include "UnityShaderVariables.cginc"
#include "UnityShaderUtilities.cginc"
// -------- variant for: <when no other keywords are defined>
#if !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_GLOSSYREFLECTIONS_OFF) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord4
#include "UnityCG.cginc"
#include "Lighting.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD5; // screenPosition
  UNITY_LIGHTING_COORDS(6,7)
  UNITY_FOG_COORDS(8)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;
float4 _texcoord4_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;
  o.color = v.color;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.uv4_texcoord4 = IN.pack0.zw;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
surfIN.vertexColor = IN.color;
#if UNITY_VFACE_FLIPPED
   vface = -vface;
#endif
surfIN.ASEVFace = vface;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
fixed4 c = 0;
float3 worldN;
worldN.x = dot(_unity_tbn_0, o.Normal);
worldN.y = dot(_unity_tbn_1, o.Normal);
worldN.z = dot(_unity_tbn_2, o.Normal);
worldN = normalize(worldN);
o.Normal = worldN;

// Setup lighting environment
UnityGI gi;
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
gi.indirect.diffuse = 0;
gi.indirect.specular = 0;
gi.light.color = _LightColor0.rgb;
gi.light.dir = lightDir;
gi.light.color *= atten;
c += LightingStandardCustom(o, worldViewDir, gi);
UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
return c;
}


#endif

// -------- variant for: LOD_FADE_CROSSFADE 
#if defined(LOD_FADE_CROSSFADE) && !defined(INSTANCING_ON) && !defined(_GLOSSYREFLECTIONS_OFF) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord4
#include "UnityCG.cginc"
#include "Lighting.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD5; // screenPosition
  UNITY_LIGHTING_COORDS(6,7)
  UNITY_FOG_COORDS(8)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;
float4 _texcoord4_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;
  o.color = v.color;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.uv4_texcoord4 = IN.pack0.zw;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
surfIN.vertexColor = IN.color;
#if UNITY_VFACE_FLIPPED
   vface = -vface;
#endif
surfIN.ASEVFace = vface;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
fixed4 c = 0;
float3 worldN;
worldN.x = dot(_unity_tbn_0, o.Normal);
worldN.y = dot(_unity_tbn_1, o.Normal);
worldN.z = dot(_unity_tbn_2, o.Normal);
worldN = normalize(worldN);
o.Normal = worldN;

// Setup lighting environment
UnityGI gi;
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
gi.indirect.diffuse = 0;
gi.indirect.specular = 0;
gi.light.color = _LightColor0.rgb;
gi.light.dir = lightDir;
gi.light.color *= atten;
c += LightingStandardCustom(o, worldViewDir, gi);
UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
return c;
}


#endif

// -------- variant for: _GLOSSYREFLECTIONS_OFF 
#if defined(_GLOSSYREFLECTIONS_OFF) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord4
#include "UnityCG.cginc"
#include "Lighting.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD5; // screenPosition
  UNITY_LIGHTING_COORDS(6,7)
  UNITY_FOG_COORDS(8)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;
float4 _texcoord4_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;
  o.color = v.color;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.uv4_texcoord4 = IN.pack0.zw;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
surfIN.vertexColor = IN.color;
#if UNITY_VFACE_FLIPPED
   vface = -vface;
#endif
surfIN.ASEVFace = vface;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
fixed4 c = 0;
float3 worldN;
worldN.x = dot(_unity_tbn_0, o.Normal);
worldN.y = dot(_unity_tbn_1, o.Normal);
worldN.z = dot(_unity_tbn_2, o.Normal);
worldN = normalize(worldN);
o.Normal = worldN;

// Setup lighting environment
UnityGI gi;
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
gi.indirect.diffuse = 0;
gi.indirect.specular = 0;
gi.light.color = _LightColor0.rgb;
gi.light.dir = lightDir;
gi.light.color *= atten;
c += LightingStandardCustom(o, worldViewDir, gi);
UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
return c;
}


#endif

// -------- variant for: _GLOSSYREFLECTIONS_OFF LOD_FADE_CROSSFADE 
#if defined(_GLOSSYREFLECTIONS_OFF) && defined(LOD_FADE_CROSSFADE) && !defined(INSTANCING_ON) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord4
#include "UnityCG.cginc"
#include "Lighting.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD5; // screenPosition
  UNITY_LIGHTING_COORDS(6,7)
  UNITY_FOG_COORDS(8)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;
float4 _texcoord4_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;
  o.color = v.color;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.uv4_texcoord4 = IN.pack0.zw;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
surfIN.vertexColor = IN.color;
#if UNITY_VFACE_FLIPPED
   vface = -vface;
#endif
surfIN.ASEVFace = vface;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
fixed4 c = 0;
float3 worldN;
worldN.x = dot(_unity_tbn_0, o.Normal);
worldN.y = dot(_unity_tbn_1, o.Normal);
worldN.z = dot(_unity_tbn_2, o.Normal);
worldN = normalize(worldN);
o.Normal = worldN;

// Setup lighting environment
UnityGI gi;
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
gi.indirect.diffuse = 0;
gi.indirect.specular = 0;
gi.light.color = _LightColor0.rgb;
gi.light.dir = lightDir;
gi.light.color *= atten;
c += LightingStandardCustom(o, worldViewDir, gi);
UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
return c;
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF 
#if defined(_SPECULARHIGHLIGHTS_OFF) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_GLOSSYREFLECTIONS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord4
#include "UnityCG.cginc"
#include "Lighting.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD5; // screenPosition
  UNITY_LIGHTING_COORDS(6,7)
  UNITY_FOG_COORDS(8)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;
float4 _texcoord4_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;
  o.color = v.color;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.uv4_texcoord4 = IN.pack0.zw;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
surfIN.vertexColor = IN.color;
#if UNITY_VFACE_FLIPPED
   vface = -vface;
#endif
surfIN.ASEVFace = vface;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
fixed4 c = 0;
float3 worldN;
worldN.x = dot(_unity_tbn_0, o.Normal);
worldN.y = dot(_unity_tbn_1, o.Normal);
worldN.z = dot(_unity_tbn_2, o.Normal);
worldN = normalize(worldN);
o.Normal = worldN;

// Setup lighting environment
UnityGI gi;
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
gi.indirect.diffuse = 0;
gi.indirect.specular = 0;
gi.light.color = _LightColor0.rgb;
gi.light.dir = lightDir;
gi.light.color *= atten;
c += LightingStandardCustom(o, worldViewDir, gi);
UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
return c;
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF LOD_FADE_CROSSFADE 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(LOD_FADE_CROSSFADE) && !defined(INSTANCING_ON) && !defined(_GLOSSYREFLECTIONS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord4
#include "UnityCG.cginc"
#include "Lighting.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD5; // screenPosition
  UNITY_LIGHTING_COORDS(6,7)
  UNITY_FOG_COORDS(8)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;
float4 _texcoord4_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;
  o.color = v.color;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.uv4_texcoord4 = IN.pack0.zw;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
surfIN.vertexColor = IN.color;
#if UNITY_VFACE_FLIPPED
   vface = -vface;
#endif
surfIN.ASEVFace = vface;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
fixed4 c = 0;
float3 worldN;
worldN.x = dot(_unity_tbn_0, o.Normal);
worldN.y = dot(_unity_tbn_1, o.Normal);
worldN.z = dot(_unity_tbn_2, o.Normal);
worldN = normalize(worldN);
o.Normal = worldN;

// Setup lighting environment
UnityGI gi;
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
gi.indirect.diffuse = 0;
gi.indirect.specular = 0;
gi.light.color = _LightColor0.rgb;
gi.light.dir = lightDir;
gi.light.color *= atten;
c += LightingStandardCustom(o, worldViewDir, gi);
UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
return c;
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF _GLOSSYREFLECTIONS_OFF 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(_GLOSSYREFLECTIONS_OFF) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord4
#include "UnityCG.cginc"
#include "Lighting.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD5; // screenPosition
  UNITY_LIGHTING_COORDS(6,7)
  UNITY_FOG_COORDS(8)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;
float4 _texcoord4_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;
  o.color = v.color;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.uv4_texcoord4 = IN.pack0.zw;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
surfIN.vertexColor = IN.color;
#if UNITY_VFACE_FLIPPED
   vface = -vface;
#endif
surfIN.ASEVFace = vface;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
fixed4 c = 0;
float3 worldN;
worldN.x = dot(_unity_tbn_0, o.Normal);
worldN.y = dot(_unity_tbn_1, o.Normal);
worldN.z = dot(_unity_tbn_2, o.Normal);
worldN = normalize(worldN);
o.Normal = worldN;

// Setup lighting environment
UnityGI gi;
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
gi.indirect.diffuse = 0;
gi.indirect.specular = 0;
gi.light.color = _LightColor0.rgb;
gi.light.dir = lightDir;
gi.light.color *= atten;
c += LightingStandardCustom(o, worldViewDir, gi);
UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
return c;
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF _GLOSSYREFLECTIONS_OFF LOD_FADE_CROSSFADE 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(_GLOSSYREFLECTIONS_OFF) && defined(LOD_FADE_CROSSFADE) && !defined(INSTANCING_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: YES
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 2 texcoords actually used
//   float2 _texcoord
//   float2 _texcoord4
#include "UnityCG.cginc"
#include "Lighting.cginc"
#include "AutoLight.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float4 pack0 : TEXCOORD0; // _texcoord _texcoord4
  float3 tSpace0 : TEXCOORD1;
  float3 tSpace1 : TEXCOORD2;
  float3 tSpace2 : TEXCOORD3;
  float3 worldPos : TEXCOORD4;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD5; // screenPosition
  UNITY_LIGHTING_COORDS(6,7)
  UNITY_FOG_COORDS(8)
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;
float4 _texcoord4_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityObjectToClipPos(v.vertex);
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  o.pack0.zw = TRANSFORM_TEX(v.texcoord3, _texcoord4);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float3(worldTangent.x, worldBinormal.x, worldNormal.x);
  o.tSpace1 = float3(worldTangent.y, worldBinormal.y, worldNormal.y);
  o.tSpace2 = float3(worldTangent.z, worldBinormal.z, worldNormal.z);
  o.worldPos.xyz = worldPos;
  o.color = v.color;

  UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
  UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN, float vface : VFACE) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.uv4_texcoord4 = IN.pack0.zw;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
surfIN.vertexColor = IN.color;
#if UNITY_VFACE_FLIPPED
   vface = -vface;
#endif
surfIN.ASEVFace = vface;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);
o.Normal = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
fixed4 c = 0;
float3 worldN;
worldN.x = dot(_unity_tbn_0, o.Normal);
worldN.y = dot(_unity_tbn_1, o.Normal);
worldN.z = dot(_unity_tbn_2, o.Normal);
worldN = normalize(worldN);
o.Normal = worldN;

// Setup lighting environment
UnityGI gi;
UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
gi.indirect.diffuse = 0;
gi.indirect.specular = 0;
gi.light.color = _LightColor0.rgb;
gi.light.dir = lightDir;
gi.light.color *= atten;
c += LightingStandardCustom(o, worldViewDir, gi);
UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
return c;
}


#endif


ENDCG

}

// ---- shadow caster pass:
Pass {
	Name "ShadowCaster"
	Tags { "LightMode" = "ShadowCaster" }
	ZWrite On ZTest LEqual

CGPROGRAM
// compile directives
#pragma vertex vert_surf
#pragma fragment frag_surf
#pragma target 3.0
#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
#pragma shader_feature _GLOSSYREFLECTIONS_OFF
#pragma multi_compile __ LOD_FADE_CROSSFADE
#pragma multi_compile_instancing
#pragma skip_variants FOG_LINEAR FOG_EXP FOG_EXP2
#pragma multi_compile_shadowcaster
#include "HLSLSupport.cginc"
#define UNITY_INSTANCED_LOD_FADE
#define UNITY_INSTANCED_SH
#define UNITY_INSTANCED_LIGHTMAPSTS
#include "UnityShaderVariables.cginc"
#include "UnityShaderUtilities.cginc"
// -------- variant for: <when no other keywords are defined>
#if !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_GLOSSYREFLECTIONS_OFF) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA
#define WorldReflectionVector(data,normal) data.worldRefl
#define WorldNormalVector(data,normal) normal

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  V2F_SHADOW_CASTER;
  float2 pack0 : TEXCOORD1; // _texcoord
  float3 worldPos : TEXCOORD2;
  float4 custompack0 : TEXCOORD3; // screenPosition
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  o.worldPos.xyz = worldPos;
  TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
SHADOW_CASTER_FRAGMENT(IN)
}


#endif

// -------- variant for: INSTANCING_ON 
#if defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_GLOSSYREFLECTIONS_OFF) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA
#define WorldReflectionVector(data,normal) data.worldRefl
#define WorldNormalVector(data,normal) normal

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  V2F_SHADOW_CASTER;
  float2 pack0 : TEXCOORD1; // _texcoord
  float3 worldPos : TEXCOORD2;
  float4 custompack0 : TEXCOORD3; // screenPosition
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  o.worldPos.xyz = worldPos;
  TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
SHADOW_CASTER_FRAGMENT(IN)
}


#endif

// -------- variant for: LOD_FADE_CROSSFADE 
#if defined(LOD_FADE_CROSSFADE) && !defined(INSTANCING_ON) && !defined(_GLOSSYREFLECTIONS_OFF) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA
#define WorldReflectionVector(data,normal) data.worldRefl
#define WorldNormalVector(data,normal) normal

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  V2F_SHADOW_CASTER;
  float2 pack0 : TEXCOORD1; // _texcoord
  float3 worldPos : TEXCOORD2;
  float4 custompack0 : TEXCOORD3; // screenPosition
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  o.worldPos.xyz = worldPos;
  TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
SHADOW_CASTER_FRAGMENT(IN)
}


#endif

// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON 
#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && !defined(_GLOSSYREFLECTIONS_OFF) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA
#define WorldReflectionVector(data,normal) data.worldRefl
#define WorldNormalVector(data,normal) normal

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  V2F_SHADOW_CASTER;
  float2 pack0 : TEXCOORD1; // _texcoord
  float3 worldPos : TEXCOORD2;
  float4 custompack0 : TEXCOORD3; // screenPosition
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  o.worldPos.xyz = worldPos;
  TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
SHADOW_CASTER_FRAGMENT(IN)
}


#endif

// -------- variant for: _GLOSSYREFLECTIONS_OFF 
#if defined(_GLOSSYREFLECTIONS_OFF) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA
#define WorldReflectionVector(data,normal) data.worldRefl
#define WorldNormalVector(data,normal) normal

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  V2F_SHADOW_CASTER;
  float2 pack0 : TEXCOORD1; // _texcoord
  float3 worldPos : TEXCOORD2;
  float4 custompack0 : TEXCOORD3; // screenPosition
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  o.worldPos.xyz = worldPos;
  TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
SHADOW_CASTER_FRAGMENT(IN)
}


#endif

// -------- variant for: _GLOSSYREFLECTIONS_OFF INSTANCING_ON 
#if defined(_GLOSSYREFLECTIONS_OFF) && defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA
#define WorldReflectionVector(data,normal) data.worldRefl
#define WorldNormalVector(data,normal) normal

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  V2F_SHADOW_CASTER;
  float2 pack0 : TEXCOORD1; // _texcoord
  float3 worldPos : TEXCOORD2;
  float4 custompack0 : TEXCOORD3; // screenPosition
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  o.worldPos.xyz = worldPos;
  TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
SHADOW_CASTER_FRAGMENT(IN)
}


#endif

// -------- variant for: _GLOSSYREFLECTIONS_OFF LOD_FADE_CROSSFADE 
#if defined(_GLOSSYREFLECTIONS_OFF) && defined(LOD_FADE_CROSSFADE) && !defined(INSTANCING_ON) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA
#define WorldReflectionVector(data,normal) data.worldRefl
#define WorldNormalVector(data,normal) normal

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  V2F_SHADOW_CASTER;
  float2 pack0 : TEXCOORD1; // _texcoord
  float3 worldPos : TEXCOORD2;
  float4 custompack0 : TEXCOORD3; // screenPosition
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  o.worldPos.xyz = worldPos;
  TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
SHADOW_CASTER_FRAGMENT(IN)
}


#endif

// -------- variant for: _GLOSSYREFLECTIONS_OFF LOD_FADE_CROSSFADE INSTANCING_ON 
#if defined(_GLOSSYREFLECTIONS_OFF) && defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA
#define WorldReflectionVector(data,normal) data.worldRefl
#define WorldNormalVector(data,normal) normal

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  V2F_SHADOW_CASTER;
  float2 pack0 : TEXCOORD1; // _texcoord
  float3 worldPos : TEXCOORD2;
  float4 custompack0 : TEXCOORD3; // screenPosition
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  o.worldPos.xyz = worldPos;
  TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
SHADOW_CASTER_FRAGMENT(IN)
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF 
#if defined(_SPECULARHIGHLIGHTS_OFF) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_GLOSSYREFLECTIONS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA
#define WorldReflectionVector(data,normal) data.worldRefl
#define WorldNormalVector(data,normal) normal

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  V2F_SHADOW_CASTER;
  float2 pack0 : TEXCOORD1; // _texcoord
  float3 worldPos : TEXCOORD2;
  float4 custompack0 : TEXCOORD3; // screenPosition
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  o.worldPos.xyz = worldPos;
  TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
SHADOW_CASTER_FRAGMENT(IN)
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF INSTANCING_ON 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_GLOSSYREFLECTIONS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA
#define WorldReflectionVector(data,normal) data.worldRefl
#define WorldNormalVector(data,normal) normal

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  V2F_SHADOW_CASTER;
  float2 pack0 : TEXCOORD1; // _texcoord
  float3 worldPos : TEXCOORD2;
  float4 custompack0 : TEXCOORD3; // screenPosition
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  o.worldPos.xyz = worldPos;
  TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
SHADOW_CASTER_FRAGMENT(IN)
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF LOD_FADE_CROSSFADE 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(LOD_FADE_CROSSFADE) && !defined(INSTANCING_ON) && !defined(_GLOSSYREFLECTIONS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA
#define WorldReflectionVector(data,normal) data.worldRefl
#define WorldNormalVector(data,normal) normal

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  V2F_SHADOW_CASTER;
  float2 pack0 : TEXCOORD1; // _texcoord
  float3 worldPos : TEXCOORD2;
  float4 custompack0 : TEXCOORD3; // screenPosition
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  o.worldPos.xyz = worldPos;
  TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
SHADOW_CASTER_FRAGMENT(IN)
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF LOD_FADE_CROSSFADE INSTANCING_ON 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && !defined(_GLOSSYREFLECTIONS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA
#define WorldReflectionVector(data,normal) data.worldRefl
#define WorldNormalVector(data,normal) normal

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  V2F_SHADOW_CASTER;
  float2 pack0 : TEXCOORD1; // _texcoord
  float3 worldPos : TEXCOORD2;
  float4 custompack0 : TEXCOORD3; // screenPosition
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  o.worldPos.xyz = worldPos;
  TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
SHADOW_CASTER_FRAGMENT(IN)
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF _GLOSSYREFLECTIONS_OFF 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(_GLOSSYREFLECTIONS_OFF) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA
#define WorldReflectionVector(data,normal) data.worldRefl
#define WorldNormalVector(data,normal) normal

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  V2F_SHADOW_CASTER;
  float2 pack0 : TEXCOORD1; // _texcoord
  float3 worldPos : TEXCOORD2;
  float4 custompack0 : TEXCOORD3; // screenPosition
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  o.worldPos.xyz = worldPos;
  TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
SHADOW_CASTER_FRAGMENT(IN)
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF _GLOSSYREFLECTIONS_OFF INSTANCING_ON 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(_GLOSSYREFLECTIONS_OFF) && defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA
#define WorldReflectionVector(data,normal) data.worldRefl
#define WorldNormalVector(data,normal) normal

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  V2F_SHADOW_CASTER;
  float2 pack0 : TEXCOORD1; // _texcoord
  float3 worldPos : TEXCOORD2;
  float4 custompack0 : TEXCOORD3; // screenPosition
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  o.worldPos.xyz = worldPos;
  TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
SHADOW_CASTER_FRAGMENT(IN)
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF _GLOSSYREFLECTIONS_OFF LOD_FADE_CROSSFADE 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(_GLOSSYREFLECTIONS_OFF) && defined(LOD_FADE_CROSSFADE) && !defined(INSTANCING_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA
#define WorldReflectionVector(data,normal) data.worldRefl
#define WorldNormalVector(data,normal) normal

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  V2F_SHADOW_CASTER;
  float2 pack0 : TEXCOORD1; // _texcoord
  float3 worldPos : TEXCOORD2;
  float4 custompack0 : TEXCOORD3; // screenPosition
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  o.worldPos.xyz = worldPos;
  TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
SHADOW_CASTER_FRAGMENT(IN)
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF _GLOSSYREFLECTIONS_OFF LOD_FADE_CROSSFADE INSTANCING_ON 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(_GLOSSYREFLECTIONS_OFF) && defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: no
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA
#define WorldReflectionVector(data,normal) data.worldRefl
#define WorldNormalVector(data,normal) normal

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}



// vertex-to-fragment interpolation data
struct v2f_surf {
  V2F_SHADOW_CASTER;
  float2 pack0 : TEXCOORD1; // _texcoord
  float3 worldPos : TEXCOORD2;
  float4 custompack0 : TEXCOORD3; // screenPosition
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  o.worldPos.xyz = worldPos;
  TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = IN.worldPos.xyz;
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
SHADOW_CASTER_FRAGMENT(IN)
}


#endif


ENDCG

}

// ---- meta information extraction pass:
Pass {
	Name "Meta"
	Tags { "LightMode" = "Meta" }
	Cull Off

CGPROGRAM
// compile directives
#pragma vertex vert_surf
#pragma fragment frag_surf
#pragma target 3.0
#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
#pragma shader_feature _GLOSSYREFLECTIONS_OFF
#pragma multi_compile __ LOD_FADE_CROSSFADE
#pragma multi_compile_instancing
#pragma skip_variants FOG_LINEAR FOG_EXP FOG_EXP2
#pragma shader_feature EDITOR_VISUALIZATION

#include "HLSLSupport.cginc"
#define UNITY_INSTANCED_LOD_FADE
#define UNITY_INSTANCED_SH
#define UNITY_INSTANCED_LIGHTMAPSTS
#include "UnityShaderVariables.cginc"
#include "UnityShaderUtilities.cginc"
// -------- variant for: <when no other keywords are defined>
#if !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_GLOSSYREFLECTIONS_OFF) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}


#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD5;
  float4 lightCoord : TEXCOORD6;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
	o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
	o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
surfIN.vertexColor = IN.color;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UnityMetaInput metaIN;
UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
metaIN.Albedo = o.Albedo;
metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: INSTANCING_ON 
#if defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_GLOSSYREFLECTIONS_OFF) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}


#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD5;
  float4 lightCoord : TEXCOORD6;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
	o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
	o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
surfIN.vertexColor = IN.color;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UnityMetaInput metaIN;
UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
metaIN.Albedo = o.Albedo;
metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: LOD_FADE_CROSSFADE 
#if defined(LOD_FADE_CROSSFADE) && !defined(INSTANCING_ON) && !defined(_GLOSSYREFLECTIONS_OFF) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}


#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD5;
  float4 lightCoord : TEXCOORD6;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
	o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
	o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
surfIN.vertexColor = IN.color;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UnityMetaInput metaIN;
UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
metaIN.Albedo = o.Albedo;
metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON 
#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && !defined(_GLOSSYREFLECTIONS_OFF) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}


#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD5;
  float4 lightCoord : TEXCOORD6;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
	o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
	o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
surfIN.vertexColor = IN.color;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UnityMetaInput metaIN;
UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
metaIN.Albedo = o.Albedo;
metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _GLOSSYREFLECTIONS_OFF 
#if defined(_GLOSSYREFLECTIONS_OFF) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}


#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD5;
  float4 lightCoord : TEXCOORD6;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
	o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
	o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
surfIN.vertexColor = IN.color;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UnityMetaInput metaIN;
UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
metaIN.Albedo = o.Albedo;
metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _GLOSSYREFLECTIONS_OFF INSTANCING_ON 
#if defined(_GLOSSYREFLECTIONS_OFF) && defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}


#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD5;
  float4 lightCoord : TEXCOORD6;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
	o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
	o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
surfIN.vertexColor = IN.color;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UnityMetaInput metaIN;
UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
metaIN.Albedo = o.Albedo;
metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _GLOSSYREFLECTIONS_OFF LOD_FADE_CROSSFADE 
#if defined(_GLOSSYREFLECTIONS_OFF) && defined(LOD_FADE_CROSSFADE) && !defined(INSTANCING_ON) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}


#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD5;
  float4 lightCoord : TEXCOORD6;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
	o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
	o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
surfIN.vertexColor = IN.color;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UnityMetaInput metaIN;
UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
metaIN.Albedo = o.Albedo;
metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _GLOSSYREFLECTIONS_OFF LOD_FADE_CROSSFADE INSTANCING_ON 
#if defined(_GLOSSYREFLECTIONS_OFF) && defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && !defined(_SPECULARHIGHLIGHTS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}


#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD5;
  float4 lightCoord : TEXCOORD6;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
	o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
	o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
surfIN.vertexColor = IN.color;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UnityMetaInput metaIN;
UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
metaIN.Albedo = o.Albedo;
metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF 
#if defined(_SPECULARHIGHLIGHTS_OFF) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_GLOSSYREFLECTIONS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}


#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD5;
  float4 lightCoord : TEXCOORD6;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
	o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
	o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
surfIN.vertexColor = IN.color;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UnityMetaInput metaIN;
UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
metaIN.Albedo = o.Albedo;
metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF INSTANCING_ON 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_GLOSSYREFLECTIONS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}


#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD5;
  float4 lightCoord : TEXCOORD6;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
	o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
	o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
surfIN.vertexColor = IN.color;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UnityMetaInput metaIN;
UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
metaIN.Albedo = o.Albedo;
metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF LOD_FADE_CROSSFADE 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(LOD_FADE_CROSSFADE) && !defined(INSTANCING_ON) && !defined(_GLOSSYREFLECTIONS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}


#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD5;
  float4 lightCoord : TEXCOORD6;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
	o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
	o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
surfIN.vertexColor = IN.color;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UnityMetaInput metaIN;
UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
metaIN.Albedo = o.Albedo;
metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF LOD_FADE_CROSSFADE INSTANCING_ON 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && !defined(_GLOSSYREFLECTIONS_OFF)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}


#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD5;
  float4 lightCoord : TEXCOORD6;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
	o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
	o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
surfIN.vertexColor = IN.color;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UnityMetaInput metaIN;
UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
metaIN.Albedo = o.Albedo;
metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF _GLOSSYREFLECTIONS_OFF 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(_GLOSSYREFLECTIONS_OFF) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}


#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD5;
  float4 lightCoord : TEXCOORD6;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
	o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
	o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
surfIN.vertexColor = IN.color;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UnityMetaInput metaIN;
UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
metaIN.Albedo = o.Albedo;
metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF _GLOSSYREFLECTIONS_OFF INSTANCING_ON 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(_GLOSSYREFLECTIONS_OFF) && defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}


#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD5;
  float4 lightCoord : TEXCOORD6;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
	o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
	o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
surfIN.vertexColor = IN.color;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UnityMetaInput metaIN;
UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
metaIN.Albedo = o.Albedo;
metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF _GLOSSYREFLECTIONS_OFF LOD_FADE_CROSSFADE 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(_GLOSSYREFLECTIONS_OFF) && defined(LOD_FADE_CROSSFADE) && !defined(INSTANCING_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}


#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD5;
  float4 lightCoord : TEXCOORD6;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
	o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
	o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
surfIN.vertexColor = IN.color;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UnityMetaInput metaIN;
UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
metaIN.Albedo = o.Albedo;
metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif

// -------- variant for: _SPECULARHIGHLIGHTS_OFF _GLOSSYREFLECTIONS_OFF LOD_FADE_CROSSFADE INSTANCING_ON 
#if defined(_SPECULARHIGHLIGHTS_OFF) && defined(_GLOSSYREFLECTIONS_OFF) && defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON)
// Surface shader code generated based on:
// vertex modifier: 'vertexDataFunc'
// writes to per-pixel normal: YES
// writes to emission: no
// writes to occlusion: YES
// needs world space reflection vector: no
// needs world space normal vector: no
// needs screen space position: no
// needs world space position: no
// needs view direction: no
// needs world space view direction: no
// needs world space position for lighting: YES
// needs world space view direction for lighting: YES
// needs world space view direction for lightmaps: no
// needs vertex color: YES
// needs VFACE: no
// passes tangent-to-world matrix to pixel shader: YES
// reads from normal: no
// 1 texcoords actually used
//   float2 _texcoord
#include "UnityCG.cginc"
#include "Lighting.cginc"

#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

// Original surface shader snippet:
#line 48 ""
#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
#endif
/* UNITY: Original start of shader */
		#include "UnityShaderVariables.cginc"
		#include "UnityStandardUtils.cginc"
		#include "UnityPBSLighting.cginc"
		//#pragma target 3.0
		//#pragma shader_feature _SPECULARHIGHLIGHTS_OFF
		//#pragma shader_feature _GLOSSYREFLECTIONS_OFF
		//#pragma multi_compile __ LOD_FADE_CROSSFADE
		//#pragma surface surf StandardCustom keepalpha addshadow fullforwardshadows exclude_path:deferred vertex:vertexDataFunc 
		struct Input
		{
			float2 uv_texcoord;
			half ASEVFace : VFACE;
			float4 vertexColor : COLOR;
			float2 uv4_texcoord4;
			float4 screenPosition;
		};

		struct SurfaceOutputStandardCustom
		{
			half3 Albedo;
			half3 Normal;
			half3 Emission;
			half Metallic;
			half Smoothness;
			half Occlusion;
			half Alpha;
			half3 Transmission;
			half3 Translucency;
		};

		uniform int _WindModeLeaves;
		uniform float _WindStrength;
		uniform float _GlobalWindInfluence;
		uniform float _RandomWindOffset;
		uniform float _WindPulse;
		uniform float _WindDirection;
		uniform float _WindTurbulence;
		uniform float _GlobalTurbulenceInfluence;
		uniform int _DoubleSidedNormalMode;
		uniform int _CullMode;
		uniform sampler2D _BumpMap;
		uniform float4 _BumpMap_ST;
		uniform half _BumpScale;
		uniform float _ColorVariation;
		uniform half _Hue;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Saturation;
		uniform float _Value;
		uniform int _ColorShifting;
		uniform float _Metallic;
		uniform float _Glossiness;
		uniform half _OcclusionStrength;
		uniform float4 _TransmissionTint;
		uniform half _Translucency;
		uniform half _TransNormalDistortion;
		uniform half _TransScattering;
		uniform half _TransDirect;
		uniform half _TransAmbient;
		uniform half _TransShadow;
		uniform float4 _TranslucencyTint;
		uniform half _Cutoff;


		float2 DirectionalEquation(float _WindDirection)
		{
			float d = _WindDirection * 0.0174532924;
			float xL = cos(d) + 1 / 2;
			float zL = sin(d) + 1 / 2;
			return float2(zL,xL);
		}


		float3 If252_g490(int m_Switch , float3 m_Leaves , float3 m_Palm , float3 m_Grass , float3 m_None)
		{
			float3 Output = m_None;
			if (m_Switch == 0) { Output = m_Leaves; }
			if (m_Switch == 1) { Output = m_Palm; }
			if (m_Switch == 2) { Output = m_Grass; }
			if (m_Switch == 3) { Output = m_None; }
			return Output;
		}


		float3 If4_g488(float Mode , float Cull , float3 Flip , float3 Mirror , float3 None)
		{
			float3 OUT = None;
			if (Cull == 0) {
				if (Mode == 0)
					OUT = Flip;
				if (Mode == 1)
					OUT = Mirror;
				if (Mode == 2)
					OUT == None;
			}
else {
   OUT = None;
}
return OUT;
}


float3 HSVToRGB(float3 c)
{
	float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}


float3 RGBToHSV(float3 c)
{
	float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
	float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

inline float Dither8x8Bayer(int x, int y)
{
	const float dither[64] = {
		 1, 49, 13, 61,  4, 52, 16, 64,
		33, 17, 45, 29, 36, 20, 48, 32,
		 9, 57,  5, 53, 12, 60,  8, 56,
		41, 25, 37, 21, 44, 28, 40, 24,
		 3, 51, 15, 63,  2, 50, 14, 62,
		35, 19, 47, 31, 34, 18, 46, 30,
		11, 59,  7, 55, 10, 58,  6, 54,
		43, 27, 39, 23, 42, 26, 38, 22};
	int r = y * 8 + x;
	return dither[r] / 64; // same # of instructions as pre-dividing due to compiler magic
}


void vertexDataFunc(inout appdata_full v, out Input o)
{
	UNITY_INITIALIZE_OUTPUT(Input, o);
	int m_Switch252_g490 = _WindModeLeaves;
	float3 ase_vertex3Pos = v.vertex.xyz;
	float3 VAR_VertexPosition21_g490 = mul(unity_ObjectToWorld, float4(ase_vertex3Pos , 0.0)).xyz;
	float3 break109_g490 = VAR_VertexPosition21_g490;
	float VAR_WindStrength43_g490 = (_WindStrength * _GlobalWindInfluence);
	float4 transform37_g490 = mul(unity_ObjectToWorld,float4(0,0,0,1));
	float2 appendResult38_g490 = (float2(transform37_g490.x , transform37_g490.z));
	float dotResult2_g491 = dot(appendResult38_g490 , float2(12.9898,78.233));
	float lerpResult8_g491 = lerp(0.8 , ((_RandomWindOffset / 2.0) + 0.9) , frac((sin(dotResult2_g491) * 43758.55)));
	float VAR_RandomTime16_g490 = (_Time.x * lerpResult8_g491);
	float FUNC_Turbulence36_g490 = (sin(((VAR_RandomTime16_g490 * 40.0) - (VAR_VertexPosition21_g490.z / 15.0))) * 0.5);
	float VAR_WindPulse274_g490 = _WindPulse;
	float FUNC_Angle73_g490 = (VAR_WindStrength43_g490 * (1.0 + sin(((((VAR_RandomTime16_g490 * 2.0) + FUNC_Turbulence36_g490) - (VAR_VertexPosition21_g490.z / 50.0)) - (v.color.r / 20.0)))) * sqrt(v.color.r) * 0.2 * VAR_WindPulse274_g490);
	float VAR_SinA80_g490 = sin(FUNC_Angle73_g490);
	float VAR_CosA78_g490 = cos(FUNC_Angle73_g490);
	float _WindDirection164_g490 = _WindDirection;
	float2 localDirectionalEquation164_g490 = DirectionalEquation(_WindDirection164_g490);
	float2 break165_g490 = localDirectionalEquation164_g490;
	float VAR_xLerp83_g490 = break165_g490.x;
	float lerpResult118_g490 = lerp(break109_g490.x , ((break109_g490.y * VAR_SinA80_g490) + (break109_g490.x * VAR_CosA78_g490)) , VAR_xLerp83_g490);
	float3 break98_g490 = VAR_VertexPosition21_g490;
	float3 break105_g490 = VAR_VertexPosition21_g490;
	float VAR_zLerp95_g490 = break165_g490.y;
	float lerpResult120_g490 = lerp(break105_g490.z , ((break105_g490.y * VAR_SinA80_g490) + (break105_g490.z * VAR_CosA78_g490)) , VAR_zLerp95_g490);
	float3 appendResult122_g490 = (float3(lerpResult118_g490 , ((break98_g490.y * VAR_CosA78_g490) - (break98_g490.z * VAR_SinA80_g490)) , lerpResult120_g490));
	float3 FUNC_vertexPos123_g490 = appendResult122_g490;
	float3 break236_g490 = FUNC_vertexPos123_g490;
	half FUNC_SinFunction195_g490 = sin(((VAR_RandomTime16_g490 * 200.0 * (0.2 + v.color.g)) + (v.color.g * 10.0) + FUNC_Turbulence36_g490 + (VAR_VertexPosition21_g490.z / 2.0)));
	float VAR_GlobalWindTurbulence194_g490 = (_WindTurbulence * _GlobalTurbulenceInfluence);
	float3 appendResult237_g490 = (float3(break236_g490.x , (break236_g490.y + (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490)) , break236_g490.z));
	float3 OUT_Leafs_Standalone244_g490 = appendResult237_g490;
	float3 m_Leaves252_g490 = OUT_Leafs_Standalone244_g490;
	float3 ase_worldNormal = UnityObjectToWorldNormal(v.normal);
	float3 ase_normWorldNormal = normalize(ase_worldNormal);
	float3 appendResult234_g490 = (float3((ase_normWorldNormal.x * v.color.g) , (ase_normWorldNormal.y / v.color.r) , (ase_normWorldNormal.z * v.color.g)));
	float3 OUT_Palm_Standalone243_g490 = (((FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)) * VAR_GlobalWindTurbulence194_g490) * appendResult234_g490) + FUNC_vertexPos123_g490);
	float3 m_Palm252_g490 = OUT_Palm_Standalone243_g490;
	float3 break221_g490 = FUNC_vertexPos123_g490;
	float temp_output_202_0_g490 = (FUNC_SinFunction195_g490 * v.color.b * (FUNC_Angle73_g490 + (VAR_WindStrength43_g490 / 200.0)));
	float lerpResult203_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_xLerp83_g490);
	float lerpResult196_g490 = lerp(0.0 , temp_output_202_0_g490 , VAR_zLerp95_g490);
	float3 appendResult197_g490 = (float3((break221_g490.x + lerpResult203_g490) , break221_g490.y , (break221_g490.z + lerpResult196_g490)));
	float3 OUT_Grass_Standalone245_g490 = appendResult197_g490;
	float3 m_Grass252_g490 = OUT_Grass_Standalone245_g490;
	float3 m_None252_g490 = FUNC_vertexPos123_g490;
	float3 localIf252_g490 = If252_g490(m_Switch252_g490 , m_Leaves252_g490 , m_Palm252_g490 , m_Grass252_g490 , m_None252_g490);
	float3 OUT_Leafs262_g490 = localIf252_g490;
	float3 temp_output_5_0_g490 = mul(unity_WorldToObject, float4(OUT_Leafs262_g490 , 0.0)).xyz;
	float3 OUT_VertexPos261 = temp_output_5_0_g490;
	v.vertex.xyz = OUT_VertexPos261;
	float4 ase_screenPos = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
	o.screenPosition = ase_screenPos;
}

inline half4 LightingStandardCustom(SurfaceOutputStandardCustom s, half3 viewDir, UnityGI gi)
{
	#if !DIRECTIONAL
	float3 lightAtten = gi.light.color;
	#else
	float3 lightAtten = lerp(_LightColor0.rgb, gi.light.color, _TransShadow);
	#endif
	half3 lightDir = gi.light.dir + s.Normal * _TransNormalDistortion;
	half transVdotL = pow(saturate(dot(viewDir, -lightDir)), _TransScattering);
	half3 translucency = lightAtten * (transVdotL * _TransDirect + gi.indirect.diffuse * _TransAmbient) * s.Translucency;
	half4 c = half4(s.Albedo * translucency * _Translucency, 0);

	half3 transmission = max(0 , -dot(s.Normal, gi.light.dir)) * gi.light.color * s.Transmission;
	half4 d = half4(s.Albedo * transmission , 0);

	SurfaceOutputStandard r;
	r.Albedo = s.Albedo;
	r.Normal = s.Normal;
	r.Emission = s.Emission;
	r.Metallic = s.Metallic;
	r.Smoothness = s.Smoothness;
	r.Occlusion = s.Occlusion;
	r.Alpha = s.Alpha;
	return LightingStandard(r, viewDir, gi) + c + d;
}

inline void LightingStandardCustom_GI(SurfaceOutputStandardCustom s, UnityGIInput data, inout UnityGI gi)
{
	#if defined(UNITY_PASS_DEFERRED) && UNITY_ENABLE_REFLECTION_BUFFERS
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal);
	#else
		UNITY_GLOSSY_ENV_FROM_SURFACE(g, s, data);
		gi = UnityGlobalIllumination(data, s.Occlusion, s.Normal, g);
	#endif
}

void surf(Input i , inout SurfaceOutputStandardCustom o)
{
	float Mode4_g488 = (float)_DoubleSidedNormalMode;
	float Cull4_g488 = (float)_CullMode;
	float2 uv_BumpMap = i.uv_texcoord * _BumpMap_ST.xy + _BumpMap_ST.zw;
	float3 bump5_g488 = UnpackScaleNormal(tex2D(_BumpMap, uv_BumpMap), _BumpScale);
	float3 Flip4_g488 = (bump5_g488 * i.ASEVFace);
	float3 break7_g488 = bump5_g488;
	float3 appendResult11_g488 = (float3(break7_g488.x , break7_g488.y , (break7_g488.z * i.ASEVFace)));
	float3 Mirror4_g488 = appendResult11_g488;
	float3 None4_g488 = bump5_g488;
	float3 localIf4_g488 = If4_g488(Mode4_g488 , Cull4_g488 , Flip4_g488 , Mirror4_g488 , None4_g488);
	float3 OUT_Normal255 = localIf4_g488;
	o.Normal = OUT_Normal255;
	float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
	float4 tex2DNode13 = tex2D(_MainTex, uv_MainTex);
	float4 VAR_AlbedoTexture267 = tex2DNode13;
	float4 VAR_Albedo101 = (_Color * VAR_AlbedoTexture267);
	float4 VAR_Albedo18_g489 = VAR_Albedo101;
	float3 hsvTorgb9_g489 = RGBToHSV(VAR_Albedo18_g489.rgb);
	float3 hsvTorgb13_g489 = HSVToRGB(float3((((i.vertexColor.g - 0.5) * _ColorVariation) + _Hue + hsvTorgb9_g489).x,(hsvTorgb9_g489.y * _Saturation),(hsvTorgb9_g489.z * _Value)));
	float4 lerpResult19_g489 = lerp(float4(hsvTorgb13_g489 , 0.0) , VAR_Albedo18_g489 , (float)_ColorShifting);
	float4 OUT_Albedo254 = lerpResult19_g489;
	o.Albedo = OUT_Albedo254.rgb;
	o.Metallic = _Metallic;
	float lerpResult268 = lerp(0.0 , VAR_AlbedoTexture267.r , _Glossiness);
	float OUT_Smoothness50 = lerpResult268;
	o.Smoothness = OUT_Smoothness50;
	float lerpResult41 = lerp(1.0 , i.vertexColor.a , _OcclusionStrength);
	float OUT_AO44 = lerpResult41;
	o.Occlusion = OUT_AO44;
	float temp_output_36_0_g486 = (1.0 - i.uv4_texcoord4.x);
	#if defined(LIGHTMAP_ON) && ( UNITY_VERSION < 560 || ( defined(LIGHTMAP_SHADOW_MIXING) && !defined(SHADOWS_SHADOWMASK) && defined(SHADOWS_SCREEN) ) )//aselc
	float4 ase_lightColor = 0;
	#else //aselc
	float4 ase_lightColor = _LightColor0;
	#endif //aselc
	float3 temp_output_37_0_g486 = (ase_lightColor.rgb * ase_lightColor.a);
	float3 OUT_Transmission350 = (((_TransmissionTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Transmission = OUT_Transmission350;
	float3 OUT_Translucency275 = (((_TranslucencyTint * temp_output_36_0_g486)).rgb * temp_output_37_0_g486 * i.vertexColor.g);
	o.Translucency = OUT_Translucency275;
	clip(tex2DNode13.a - _Cutoff);
	float temp_output_41_0_g487 = tex2DNode13.a;
	float4 ase_screenPos = i.screenPosition;
	float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
	ase_screenPosNorm.z = (UNITY_NEAR_CLIP_VALUE >= 0) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
	float2 clipScreen45_g487 = ase_screenPosNorm.xy * _ScreenParams.xy;
	float dither45_g487 = Dither8x8Bayer(fmod(clipScreen45_g487.x, 8), fmod(clipScreen45_g487.y, 8));
	dither45_g487 = step(dither45_g487, unity_LODFade.x);
	#ifdef LOD_FADE_CROSSFADE
		float staticSwitch40_g487 = (temp_output_41_0_g487 * dither45_g487);
	#else
		float staticSwitch40_g487 = temp_output_41_0_g487;
	#endif
	float OUT_Alpha46 = staticSwitch40_g487;
	o.Alpha = OUT_Alpha46;
}


#include "UnityMetaPass.cginc"

// vertex-to-fragment interpolation data
struct v2f_surf {
  UNITY_POSITION(pos);
  float2 pack0 : TEXCOORD0; // _texcoord
  float4 tSpace0 : TEXCOORD1;
  float4 tSpace1 : TEXCOORD2;
  float4 tSpace2 : TEXCOORD3;
  fixed4 color : COLOR0;
  float4 custompack0 : TEXCOORD4; // screenPosition
#ifdef EDITOR_VISUALIZATION
  float2 vizUV : TEXCOORD5;
  float4 lightCoord : TEXCOORD6;
#endif
  UNITY_VERTEX_INPUT_INSTANCE_ID
  UNITY_VERTEX_OUTPUT_STEREO
};
float4 _texcoord_ST;

// vertex shader
v2f_surf vert_surf(appdata_full v) {
  UNITY_SETUP_INSTANCE_ID(v);
  v2f_surf o;
  UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
  UNITY_TRANSFER_INSTANCE_ID(v,o);
  UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
  Input customInputData;
  vertexDataFunc(v, customInputData);
  o.custompack0.xyzw = customInputData.screenPosition;
  o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);
#ifdef EDITOR_VISUALIZATION
  o.vizUV = 0;
  o.lightCoord = 0;
  if (unity_VisualizationMode == EDITORVIZ_TEXTURE)
	o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);
  else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)
  {
	o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
	o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz, 1)));
  }
#endif
  o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
  float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
  float3 worldNormal = UnityObjectToWorldNormal(v.normal);
  fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
  fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
  fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
  o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
  o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
  o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
  o.color = v.color;
  return o;
}

// fragment shader
fixed4 frag_surf(v2f_surf IN) : SV_Target {
  UNITY_SETUP_INSTANCE_ID(IN);
// prepare and unpack data
Input surfIN;
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
#elif defined (FOG_COMBINED_WITH_WORLD_POS)
  UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
#else
  UNITY_EXTRACT_FOG(IN);
#endif
#ifdef FOG_COMBINED_WITH_TSPACE
  UNITY_RECONSTRUCT_TBN(IN);
#else
  UNITY_EXTRACT_TBN(IN);
#endif
UNITY_INITIALIZE_OUTPUT(Input,surfIN);
surfIN.uv_texcoord.x = 1.0;
surfIN.ASEVFace.x = 1.0;
surfIN.vertexColor.x = 1.0;
surfIN.uv4_texcoord4.x = 1.0;
surfIN.screenPosition.x = 1.0;
surfIN.uv_texcoord = IN.pack0.xy;
surfIN.screenPosition = IN.custompack0.xyzw;
float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
#ifndef USING_DIRECTIONAL_LIGHT
  fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
#else
  fixed3 lightDir = _WorldSpaceLightPos0.xyz;
#endif
surfIN.vertexColor = IN.color;
#ifdef UNITY_COMPILER_HLSL
SurfaceOutputStandardCustom o = (SurfaceOutputStandardCustom)0;
#else
SurfaceOutputStandardCustom o;
#endif
o.Albedo = 0.0;
o.Emission = 0.0;
o.Alpha = 0.0;
o.Occlusion = 1.0;
fixed3 normalWorldVertex = fixed3(0,0,1);

// call surface function
surf(surfIN, o);
UnityMetaInput metaIN;
UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);
metaIN.Albedo = o.Albedo;
metaIN.Emission = o.Emission;
#ifdef EDITOR_VISUALIZATION
  metaIN.VizUV = IN.vizUV;
  metaIN.LightCoord = IN.lightCoord;
#endif
  return UnityMetaFragment(metaIN);
}


#endif


ENDCG

}

// ---- end of surface shader generated code

#LINE 339

		}
			Fallback "Diffuse"
}